{
    "collab_server" : "",
    "contents" : "#### Analysis of field data\n# Sam Flake, 12 Sep 2017\n# sflake@gmail.com or swflake@ncsu.edu\n\n\n# load libraries\nlibrary(plyr)\nlibrary(boot)\nlibrary(lme4)\nlibrary(MuMIn)\nlibrary(car)\nlibrary(effects)\nlibrary(pscl)\nlibrary(\"pROC\")\n\n## set up some options\nset.seed(665224291)\noptions(na.action = na.fail)\npardefault <- par(no.readonly = T)\n\n#Source some useful functions\nsource(\"pj_mortality_functions_090617.R\")\n\n#read prepared data\nall_tree_vars <- read.csv(\"./Clean data/all_tree_Vars_scaled_and_transformed.csv\")\nall_tree_vars_orig <- read.csv(\"./Clean data/all_tree_Vars_unscaled_untrans.csv\")\n\n#--------------------------------------------------------------------------------------------\n# tree-level models\n\n#global model with tree-level vars and abiotic vars\npimo_global <- lmer(formula = Delta_pdc ~ Neighbor_larger_log + ENN_dist_log + Diam_log + Height + BA_4m_log +  \n                          cwd_normal_cum + fdsi_anom +\n                          cwd_peak_anom + tmean + ppt +\n                          vpd_normal_annual_max + vpd_peak_anom + avg_summer_tmax +\n                          peak_tmax + min_ann_ppt +\n                          Pndjfm + Avg_depth + AWC +\n                          (1|Cluster/site), \n                      data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ],\n                    na.action = na.fail)\n\n#only use combos that aren't pairwise correlated\ncormat <- abs(cor(all_tree_vars[all_tree_vars$Spp == \"PIMO\", c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log', \n                                                               'cwd_normal_cum', 'fdsi_anom',\n                                                                   'cwd_peak_anom' , 'tmean', 'ppt',\n                                                                   'vpd_normal_annual_max' , 'vpd_peak_anom' , 'avg_summer_tmax', 'peak_tmax',\n                                                                   'min_ann_ppt',  'Pndjfm' , 'Avg_depth' , 'AWC')])) <=.5\n\n#use all tree-level vars\ncormat[1:5,1:5] <- TRUE\n\n#use only one side of matrix (avoid duplicated models)\ncormat[!lower.tri(cormat)] <- NA\n\n#find all combinations with a few given conditions: \n# abiotic variables can change but stand structure variables are fixed;\n# abiotic variables with correlations greater than .5 are not allowed;\n# 9 maximum variables are allowed;\n# progress is displayed in console\n\n# this only takes a minute or two\npimo_dredge <- dredge(pimo_global, \n                      fixed = c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log'),\n                      subset = cormat, \n                      m.lim = c(5, 8), \n                      trace = 2)\n\nsaveRDS(pimo_dredge, \"./model output/pimo_dredge.RDS\")\n\n#get call for top model and evaluate it\nbest_pimo_call <- as.character(unlist(attr((pimo_dredge)[1], \"model.calls\")))\npimo_model_dredge <- eval(parse(text = best_pimo_call))\nsummary(pimo_model_dredge)\n\npimo_dredge[1:10] #top 10 models\nwrite.csv(pimo_dredge[1:10], \"./model output/pimo_mod_selection_table.csv\")\n\n# #----------------------------------------------\n# \n\n#global model with tree-level vars and abiotic vars\njuos_global <- lmer(formula = Delta_pdc ~ Neighbor_larger_log + ENN_dist_log + Diam_log + Height + BA_4m_log +  \n                      cwd_normal_cum + fdsi_anom +\n                      cwd_peak_anom + tmean + ppt +\n                      vpd_normal_annual_max + vpd_peak_anom + avg_summer_tmax +\n                      peak_tmax + min_ann_ppt +\n                      Pndjfm + Avg_depth + AWC +\n                      (1|Cluster/site), \n                    data = all_tree_vars[all_tree_vars$Spp == \"JUOS\", ],\n                    na.action = na.fail)\n\n#only use combos that aren't pairwise correlated\ncormat <- abs(cor(all_tree_vars[all_tree_vars$Spp == \"JUOS\", c('Neighbor_larger_log', 'ENN_dist_log', 'Height', 'Diam_log', 'BA_4m_log', \n                                                               'cwd_normal_cum', 'fdsi_anom',\n                                                               'cwd_peak_anom' , 'tmean', 'ppt',\n                                                               'vpd_normal_annual_max' , 'vpd_peak_anom' , 'avg_summer_tmax', 'peak_tmax',\n                                                               'min_ann_ppt',  'Pndjfm' , 'Avg_depth' , 'AWC')])) <=.5\n\n#use all tree-level vars\ncormat[1:5,1:5] <- TRUE\n\n#use only one side of matrix (avoid duplicated models)\ncormat[!lower.tri(cormat)] <- NA\n\n#find all combinations\njuos_dredge <- dredge(juos_global, \n                      fixed = c('Neighbor_larger_log', 'ENN_dist_log', 'Height', 'Diam_log', 'BA_4m_log'),\n                      subset = cormat, \n                      m.lim = c(5, 8), \n                      trace = 2)\n\nsaveRDS(juos_dredge, \"./model output/juos_dredge.RDS\")\n\n#get call for top model and evaluate it\nbest_juos_call <- as.character(unlist(attr((juos_dredge)[1], \"model.calls\")))\njuos_model_dredge <- eval(parse(text = best_juos_call))\n\nwrite.csv(juos_dredge[1:10], \"./model output/juos_mod_selection_table.csv\")\n\n\n# \n# ###################################\n# # PIMO mortality\n# ###################################\npmort_global <- glmer(formula = Died ~ Neighbor_larger_log + ENN_dist_log + Diam_log + Height + BA_4m_log +  \n                        cwd_normal_cum + fdsi_anom +\n                        cwd_peak_anom + tmean + ppt +\n                        vpd_normal_annual_max + vpd_peak_anom + avg_summer_tmax +\n                        peak_tmax + min_ann_ppt +\n                        Pndjfm + Avg_depth + AWC +\n                      (1|site), family = \"binomial\",\n                      data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ], na.action = na.fail)\n\n#only use combos that aren't pairwise correlated\ncormat <- abs(cor(all_tree_vars[all_tree_vars$Spp == \"PIMO\", c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log', \n                                                               'cwd_normal_cum', 'fdsi_anom',\n                                                               'cwd_peak_anom' , 'tmean', 'ppt',\n                                                               'vpd_normal_annual_max' , 'vpd_peak_anom' , 'avg_summer_tmax', 'peak_tmax',\n                                                               'min_ann_ppt',  'Pndjfm' , 'Avg_depth' , 'AWC')])) <=.5\n\n#use all tree-level vars\ncormat[1:5,1:5] <- TRUE\n\n#use only one side of matrix (avoid duplicated models)\ncormat[!lower.tri(cormat)] <- NA\n\n# find all combinations with a few given conditions: \n# abiotic variables can change but stand structure variables are fixed;\n# abiotic variables with correlations greater than .5 are not allowed;\n# 8 maximum variables are allowed;\n# progress is displayed in console\n\n# this only takes a half an hour or so\nstart.time <- Sys.time()\npmort_dredge <- dredge(pmort_global, \n                      fixed = c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log'),\n                      subset = cormat, \n                      m.lim = c(5, 8), \n                      trace = 2)\nend.time <- Sys.time()\n\ntime.taken_pmort_dredge <- end.time - start.time\ntime.taken_pmort_dredge #30 minutes\n\n\nsaveRDS(pmort_dredge, \"./model output/pmort_dredge.RDS\")\n\n(pmort_dredge)[c(1:10)]\n\n#get call for top model and evaluate it\nbest_pmort_call <- as.character(unlist(attr((pmort_dredge)[1], \"model.calls\")))\npmort_model_dredge <- eval(parse(text = best_pmort_call))\nwrite.csv(pmort_dredge[1:10], \"./model output/pmort_mod_selection_table.csv\")\n\n\n#############################################################################################\n#Tree-level models\n#############################################################################################\n\n#PIMO dieback\n\n#add interaction term to the PIMO dieback model\npimo_int_ba <- update(pimo_model_dredge, . ~ . + BA_4m_log:cwd_normal_cum)\n\nsummary(pimo_int_ba)\nsaveRDS(pimo_int_ba, \"./model output/pimo_model.rds\")\n\nAICc(pimo_model_dredge) - AICc(pimo_int_ba) #improves AICc by 3.8\n\n#nonparametric bootstrap cis\nbs <- function(formula, data, indices) {\n  d <- data[indices,] # allows boot to select sample \n  fit <- lmer(formula, data=d)\n  return(fixef(fit)) \n} \n\nbs(formula = pimo_int_ba@call,\n   data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n\n# bootstrapping with 5000 replications\n#this takes a while (~6 hrs on an i7 3.4 Ghz processor. Would be faster with multithreading)\nstart.time <- Sys.time()\nbootstrap_pimo_int <- boot(data=all_tree_vars[all_tree_vars$Spp == \"PIMO\", ], \n                                statistic=bs, \n                                R=5000, \n                                formula= pimo_int_ba@call,\n                                parallel = \"no\")\nend.time <- Sys.time()\ntime.taken_pimo <- end.time - start.time\ntime.taken_pimo\n\nsaveRDS(bootstrap_pimo_int, file = paste0(\"./model output/bootstrap_pimo_int.rds\"))\n\n# view results\nbootstrap_pimo <- bootstrap_pimo_int\nsummary(bootstrap_pimo)\nplot(bootstrap_pimo, index=1) # intercept\nplot(bootstrap_pimo, index=2) #\nplot(bootstrap_pimo, index=3) #\n\n# get 95% confidence intervals \nci_pimo <- cbind(attr(bootstrap_pimo_int$t0, \"names\"), summary(bootstrap_pimo_int))\nci_pimo$lo <- NA\nci_pimo$hi <- NA\n\nfor( i in 1:nrow(ci_pimo)){\n  ci_boot <- boot.ci(bootstrap_pimo_int, type = \"bca\", index = i)\n  #extract low and hi, add to ci_pimo df\n  ci_pimo$lo[i] <- ci_boot$bca[1,4]\n  ci_pimo$hi[i] <- ci_boot$bca[1,5]\n  ci_pimo$mean[i] <- mean(bootstrap_pimo_int$t[, i])\n}\n\nsaveRDS(ci_pimo, file = \"./model output/ci_pimo.rds\")\nwrite.csv(ci_pimo, \"./model output/ci_pimo.csv\")\n\n# plot(allEffects(pimo_model))\n#    plot(Effect(focal.predictors = c(\"ENN_dist\", \"Neighbor_larger\"), mod = pimo_model, \n#                ylim = c(-40, 0), partial.residuals = TRUE))\n#    plot(Effect(focal.predictors = c(\"BA_4m\", \"cwd_normal_cum\"), mod = pimo_int_ba, \n#                ylim = c(-40, 0), partial.residuals = TRUE))\n# coefplot2::coefplot2(pimo_model)\n# AICc(pimo_model)\n# vif.mer(pimo_model)\n# r.squaredGLMM(pimo_int_ba)\n# \n# plot(resid(pimo_int_ba) ~ predict(pimo_int_ba))\n# abline(h=0)\n# hist(resid(pimo_int_ba))\n# mse <- sum(resid(pimo_int_ba)^2)*(1 / length(resid(pimo_int_ba)))\n# \n# \n# qqmath(ranef(pimo_model, postVar = TRUE))\n\n#--------------------------------------------------------------\n\n# add interaction to the selected model\njuos_int_enn <- update(juos_model_dredge, . ~ . + ENN_dist_log:Neighbor_larger_log)\n\nsummary(juos_int_enn)\nsaveRDS(juos_int_enn, \"./model output/juos_model.rds\")\n\n\n#nonparametric bootstrap cis\nbs <- function(formula, data, indices) {\n  d <- data[indices,] # allows boot to select sample \n  fit <- lmer(formula, data=d)\n  return(fixef(fit)) \n} \n\n\nbs(formula = juos_int_enn@call,\n   data = all_tree_vars[all_tree_vars$Spp == \"JUOS\", ])\n\n# bootstrapping with 5000 replications\n#this takes a while (~3.5 hrs on an i7 3.4 Ghz processor. Would be faster with multithreading)\nstart.time <- Sys.time()\nbootstrap_juos <- boot(data=all_tree_vars[all_tree_vars$Spp == \"JUOS\", ], \n                       statistic=bs, \n                       R=5000, \n                       formula=juos_int_enn@call)\n\n\nend.time <- Sys.time()\ntime.taken_juos <- end.time - start.time\ntime.taken_juos\n\nsaveRDS(bootstrap_juos, file = \"./model output/bootstrap_juos.rds\")\n\n# view results\n# bootstrap_juos\n# summary(bootstrap_juos)\n# plot(bootstrap_juos, index=1) # intercept\n# plot(bootstrap_juos, index=2) #\n# plot(bootstrap_juos, index=3) #\n# plot(bootstrap_juos, index=4) #\n# plot(bootstrap_juos, index=5) #\n# plot(bootstrap_juos, index=6) #\n# plot(bootstrap_juos, index=7) #\n# plot(bootstrap_juos, index=8) #\n# plot(bootstrap_juos, index=9) #\n# plot(bootstrap_juos, index=10) #\n\n# get 95% confidence intervals \nci_juos <- cbind(attr(bootstrap_juos$t0, \"names\"), summary(bootstrap_juos))\nci_juos$lo <- NA\nci_juos$hi <- NA\n\nfor( i in 1:nrow(ci_juos)){\n  ci_boot <- boot.ci(bootstrap_juos, type = \"bca\", index = i)\n  #extract low and hi, add to ci_pimo df\n  ci_juos$lo[i] <- ci_boot$bca[1,4]\n  ci_juos$hi[i] <- ci_boot$bca[1,5]\n  ci_juos$mean[i] <- mean(bootstrap_juos$t[, i])\n}\n\nsaveRDS(ci_juos, file = \"./model output/ci_juos.rds\")\n\nwrite.csv(ci_juos, \"./model output/ci_juos.csv\")\n\n# plot(allEffects(juos_model))\n#   plot(Effect(focal.predictors = c(\"ENN_dist\", \"Neighbor_larger\"), mod = juos_model, partial.residuals = TRUE), ylim = c(-20, 0))\n#   coefplot2::coefplot2(juos_model)\n#   AICc(juos_model)\n#   vif.mer(juos_model)\n#   r.squaredGLMM(juos_int_enn)\n#   \n#   plot(resid(juos_int_enn) ~ predict(juos_int_enn))\n#   abline(h = 0)\n#   hist(resid(juos_int_enn))\n#   mse <- sum(resid(juos_int_enn)^2)*(1 / length(resid(juos_int_enn)))\n\n#####################################\n# Below here is PIMO mortality stuff\n## PIMO mortality\n\n#full model\np_mort <- pmort_model_dredge\n\nsummary(p_mort)\n\nsaveRDS(p_mort, \"./model output/pimo_mort_model.rds\")\n\n  ## scale the gradient by the hessian to get relative gradient, \n  # see Bolker comments at https://github.com/lme4/lme4/issues/120\n  relgrad <- with(p_mort@optinfo$derivs,solve(Hessian,gradient))\n  max(abs(relgrad))\n  #looks good!\n\n# bootstrapping with 5000 replications\n#this takes a while (1.1 days on an i7 3.4 Ghz processor. Would be faster with multithreading)\n\nbs <- function(formula, data, indices) {\n  d <- data[indices,] # allows boot to select sample \n  fit <- glmer(formula, data=d, nAGQ = 1, family = \"binomial\")\n  return(fixef(fit)) \n} \nstart.time <- Sys.time()\nbootstrap_pmort <- boot(data=all_tree_vars[all_tree_vars$Spp == \"PIMO\", ], \n                       statistic=bs, \n                       R=5000, \n                       formula = p_mort@call)\nend.time <- Sys.time()\ntime.taken_pmort <- end.time - start.time\ntime.taken_pmort\n\nsaveRDS(bootstrap_pmort, file = \"./model output/bootstrap_pmort.rds\")\n\n# view results\n# # view results\n# bootstrap_pmort\n# summary(bootstrap_pmort)\n# plot(bootstrap_pmort, index=1) # intercept x\n# plot(bootstrap_pmort, index=2) #\n# plot(bootstrap_pmort, index=3) #\n# plot(bootstrap_pmort, index=4) #\n# plot(bootstrap_pmort, index=5) #\n# plot(bootstrap_pmort, index=6) #\n# plot(bootstrap_pmort, index=7) #\n# plot(bootstrap_pmort, index=8) #\n# plot(bootstrap_pmort, index=9) #\n# plot(bootstrap_pmort, index=10) #\n\n# get 95% confidence intervals \nci_pmort <- cbind(attr(bootstrap_pmort$t0, \"names\"), summary(bootstrap_pmort))\nci_pmort$lo <- NA\nci_pmort$hi <- NA\n\nfor( i in 1:nrow(ci_pmort)){\n  ci_boot <- boot.ci(bootstrap_pmort, type = \"bca\", index = i)\n  #extract low and hi, add to ci_pimo df\n  ci_pmort$lo[i] <- ci_boot$bca[1,4]\n  ci_pmort$hi[i] <- ci_boot$bca[1,5]\n  ci_pmort$mean[i] <- mean(bootstrap_pmort$t[, i])\n}\n\nsaveRDS(ci_pmort, file = \"./model output/ci_pmort.rds\")\n\nwrite.csv(ci_pmort, \"./model output/ci_pmort.csv\")\n\n\n",
    "created" : 1508960246093.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2144467936",
    "id" : "FDB48D68",
    "lastKnownWriteTime" : 1508964565,
    "last_content_update" : 1508964565476,
    "path" : "C:/Users/Sam/Google Drive/Projects/MS Thesis/Flake and Weisberg PJ mortality analysis/ind_tree_analysis_for_paper_102517.R",
    "project_path" : "ind_tree_analysis_for_paper_102517.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}