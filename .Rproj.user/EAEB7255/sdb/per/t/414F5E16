{
    "collab_server" : "",
    "contents" : "# Create figures for Flake and Weisberg PJ Mortality\nlibrary(\"effects\")\nlibrary(\"lme4\")\n\nsource(\"pj_mortality_functions_090617.R\")\n\n##############################################\n# Figure SXXX\n# Does PDC predict mortality?\n\n# #only climate vars\np_mort_clim <- glmer(Died ~\n                       Avg_depth + cwd_normal_cum + fdsi_anom + (1| site), nAGQ = 1, family = \"binomial\",\n                     data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\nsummary(p_mort_clim)\nplot(allEffects(p_mort_clim))\ncoefplot2::coefplot2(p_mort_clim)\nAICc(p_mort_clim)\nvif.mer(p_mort_clim)\nr.squaredGLMM(p_mort_clim)\n\n#only stand structure vars\np_mort_stand <- glmer(Died ~ ENN_dist + Neighbor_larger + BA_4m +\n                        (1|Cluster/site), nAGQ = 1, family = \"binomial\",\n                      data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\nsummary(p_mort_stand)\nplot(allEffects(p_mort_stand))\ncoefplot2::coefplot2(p_mort_stand)\nAICc(p_mort_stand)\nvif.mer(p_mort_stand)\nr.squaredGLMM(p_mort_stand)\n\n\n\n#only tree-level vars\np_mort_tree <- glmer(Died ~ Height + Diam +\n                       (1|Cluster/site), nAGQ = 1, family = \"binomial\",\n                     data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\nsummary(p_mort_tree)\nplot(allEffects(p_mort_tree))\ncoefplot2::coefplot2(p_mort_tree)\nAICc(p_mort_tree)\nvif.mer(p_mort_tree)\nr.squaredGLMM(p_mort_tree)\n\n\n\n#intercept-only model\np_mort_int <- glm(Died ~ 1, family = \"binomial\",\n                  data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n\n# random effects only model\np_mort_int_mix <- glmer(Died ~ 1 + (1| site), nAGQ = 1, family = \"binomial\",\n                        data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n\n## Testing effect of different forms of PDC05 (percent dead crown in 2005)\n\npdc_mort <- update(p_mort, . ~ . + PDC05)\nrelgrad <- with(pdc_mort@optinfo$derivs,solve(Hessian,gradient))\nmax(abs(relgrad))\nplot(allEffects(pdc_mort))\n\npdc_mort_poly <- update(p_mort, . ~ . + poly(PDC05, 2))\nrelgrad <- with(pdc_mort_poly@optinfo$derivs,solve(Hessian,gradient))\nmax(abs(relgrad))\nplot(allEffects(pdc_mort_poly))\n\npdc_mort_exp <- update(p_mort, . ~ . + exp(PDC05))\nrelgrad <- with(pdc_mort_exp@optinfo$derivs,solve(Hessian,gradient))\nmax(abs(relgrad))\n\n#these  models aren't great but close enough to be useful, I think\n\n\n## Model comparisons\nAICc(p_mort)\nAICc(p_mort_clim)\nAICc(p_mort_stand)\nAICc(p_mort_tree)\nAICc(p_mort_int)\nAICc(p_mort_int_mix)\n\nAICc(pdc_mort)\nAICc(pdc_mort_poly)\nAICc(pdc_mort_exp)\n\nr.squaredGLMM(p_mort)\nr.squaredGLMM(p_mort_clim)\nr.squaredGLMM(p_mort_stand)\nr.squaredGLMM(p_mort_tree)\npR2(p_mort_int)\nr.squaredGLMM(p_mort_int_mix)\n\n\nr.squaredGLMM(pdc_mort)\nr.squaredGLMM(pdc_mort_poly)\nr.squaredGLMM(pdc_mort_exp)\n\n# hists and confusion matrices; not finished\nhist(fitted(p_mort)[all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"Y\"])\nhist(fitted(p_mort)[all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"N\"])\nhist(fitted(p_mort)[which(all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"Y\")])\nhist(fitted(p_mort)[which(all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"N\")])\n\n######################################################\n# Figure SXXX\n# Plot the ROCs, adding the AUC for each\n######################################################\ntiff(filename=\"./plots/roc_plots.tiff\", \n     type=\"cairo\",\n     units=\"in\", \n     width = 8, \n     height=8, \n     pointsize=15, \n     res=160)\n\npar(mar = c(5.1, 4.1, 2.1, 2.1))\n\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(p_mort_int),print.auc = TRUE, \n         col = \"green\", lty = 2)\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(p_mort_int_mix),print.auc = TRUE,\n         add = TRUE, col = \"violet\", lty = 4, print.auc.y = 0.45)\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(p_mort),print.auc = TRUE,\n         add = TRUE, col = \"black\", print.auc.y = 0.4)\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(pdc_mort_poly),add = TRUE,\n         print.auc = TRUE, lty = 5, col = \"blue\", print.auc.y = 0.35)\nlegend(\"bottomright\", legend = c(\"Fixed Intercept\", \"Random Intercepts\", \"Full Model\", \"Full Model with PDC\"),\n       col = c(\"green\", \"violet\", \"black\", \"blue\"), \n       lty = c(2, 4, 1, 5),\n       lwd = 2,\n       cex = 1)\n\ndev.off()\n\n\n#########################\n## Classification accuracy\n########################\n\n#calculate classification accuracy for a given threshold\nclass_acc <- function(mod, thresh = .5){\n  con <- data.frame(fitted(mod), as.factor(all_tree_vars$Died[all_tree_vars$Spp == \"PIMO\"]))\n  nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n  true_pos <- nrow((con[con[, 1] > thresh & con[, 2] == \"Y\", ]))\n  false_pos <- nrow((con[con[, 1] > thresh & con[, 2] == \"N\", ]))\n  true_neg <- nrow((con[con[, 1] < thresh & con[, 2] == \"N\", ]))\n  false_neg <- nrow((con[con[, 1] < thresh & con[, 2] == \"Y\", ]))\n  accuracy <- (true_pos + true_neg) / length(fitted(mod))\n  return(accuracy)\n}\n\n\n# \n# class_acc(p_mort, .5)\n# class_acc(p_mort_clim, .5)\n# class_acc(p_mort_stand, .5)\n# class_acc(p_mort_tree, .5)\n# class_acc(p_mort_int, .5)\n# class_acc(p_mort_int_mix, .5)\n# \n# class_acc(pdc_mort, .5)\n# class_acc(pdc_mort_poly, .5)\n# class_acc(pdc_mort_exp, .5)\n\n\nca_pmort <- NA\nfor(i in 1:100){\n  ca_pmort[i] <- class_acc(p_mort, thresh = i / 100)\n}\nca_pmort_clim <- NA\nfor(i in 1:100){\n  ca_pmort_clim[i] <- class_acc(p_mort_clim, thresh = i / 100)\n}\nca_pmort_pdc_poly <- NA\nfor(i in 1:100){\n  ca_pmort_pdc_poly[i] <- class_acc(pdc_mort_poly, thresh = i / 100)\n}\nca_pmort_int <- NA\nfor(i in 1:100){\n  ca_pmort_int[i] <- class_acc(p_mort_int, thresh = i / 100)\n}\nca_pmort_int_mix <- NA\nfor(i in 1:100){\n  ca_pmort_int_mix[i] <- class_acc(p_mort_int_mix, thresh = i / 100)\n}\n\n## Plot of classification accuracy ~ threshold\ntiff(filename=\"./plots/classification_accuracy.tif\", \n     type = \"cairo\",\n     antialias = \"gray\",\n     compression = \"lzw\",\n     units=\"in\", \n     width = 8, \n     height=7, \n     pointsize=15, \n     res=600)\n\npar(mar = c(5.1, 4.1, 2.1, 2.1))\n\nplot(NA,\n     xlim = c(0, 100),\n     ylim = c(0, 1),\n     xlab = \"Threshold\",\n     ylab = \"Classification Accuracy\",\n     xaxt = 'n',\n     yaxt = 'n',\n     cex = 1.7)\nlines(ca_pmort_int, lty = 2, lwd = 2, col = \"green\")\nlines(ca_pmort_int_mix, lty = 4, lwd = 2, col = \"violet\")\nlines(ca_pmort, lwd = 2, col = \"black\")\nlines(ca_pmort_pdc_poly, lwd = 2, lty = 5, col = \"blue\")\naxis(side = 1, at = c(0, 20, 40, 60, 80, 100), tick = TRUE,\n     labels = c(\"0.00\", \"0.20\", \"0.40\", \"0.60\", \"0.80\", \"1.00\"))\naxis(side = 2, at = c(0, .2, .4, .6, .8, 1), tick = TRUE,\n     labels = c(\"0.00\", \"0.20\", \"0.40\", \"0.60\", \"0.80\", \"1.00\"))\nlegend(\"bottomright\", legend = c(\"Fixed Intercept\", \"Random Intercepts\", \"Full Model\", \"Full Model with PDC\"),\n       col = c(\"green\", \"violet\", \"black\", \"blue\"), \n       lty = c(2, 4, 1, 5),\n       lwd = 2,\n       cex = 1.2)\n\ndev.off()\n\n\n###############################################################\n#### Generate figure 4\n###############################################################\nbootstrap_pmort <- readRDS(\"./model output/bootstrap_pmort.rds\")\n\npdc_mort_poly <- update(p_mort, . ~ . + poly(PDC05, 2))\n\n####partial effect plot of 2005 PDC on mortality risk 2005-2015\n\nminx <- -mean(all_tree_vars_orig$PDC05)/sd(all_tree_vars_orig$PDC05)\nmaxx <- (95-mean(all_tree_vars_orig$PDC05))/sd(all_tree_vars_orig$PDC05)\n\n\n\n#PDC05 effect from model\nmort_eff <- Effect(pdc_mort_poly, focal.predictors = c(\"PDC05\"), xlevels = list(PDC05 = seq(minx,maxx,length.out = 100)))\n\n#prediction and 1-se envelope\nx <- unlist(mort_eff$x)*sd(all_tree_vars_orig$PDC05) + mean(all_tree_vars_orig$PDC05) #unscale x variable\nup <- exp(unlist(mort_eff$fit) + (mort_eff$se))\nlow <- exp(unlist(mort_eff$fit) - (mort_eff$se))\ny <- exp(unlist(mort_eff$fit))\n\ntiff(filename=\"./plots/Figure_4_pdc_mort_effects.tif\", \n     type = \"cairo\",\n     antialias = \"gray\",\n     compression = \"lzw\",\n     units=\"in\", \n     width = 3, \n     height=3, \n     pointsize=15, \n     res=600)\n\npar(mar = c(2.5,2.5,0.2,0.2),\n    oma = c(1,1,0.2,0.2),\n    family = \"serif\")\n\nplot(y ~ x, \n     ylim = c(0, 0.3),\n     xlim = c(0, 100),\n     type = \"l\",\n     bty = \"n\",\n     xlab = \"\",\n     ylab = \"\",\n     xaxt = \"n\",\n     yaxt = \"n\",\n     lwd = 2)\nlines(up ~ x)\nlines(low ~ x)\npolygon(c(x, rev(x)), c(up, rev(low)),\n        col = addTrans(\"grey30\",30), border = NA) #fills in the area between high and low confidence intervals\naxis(1, cex.axis = 0.7, at= c(0, 50, 100))\naxis(2, cex.axis = 0.7, at = c(0, 0.1, 0.2, .3))\nmtext(text = \"Percent dead canopy in 2005\", side = 1, cex = 0.8, line = 2.3)\nmtext(text = \"p(mortality), 2005-2015\", side = 2, cex = 0.8, line = 2.3)\n\n\ndev.off()\n\n\n#------------------------------------------------------------\n## Plots for bootstraps of variable values\n#-------------------------------------------------\n#Generate Figure 3\n\nbootstrap_pimo_int <- readRDS(\"./model output/bootstrap_pimo_int.rds\")\nbootstrap_juos <- readRDS(\"./model output/bootstrap_juos.rds\")\nbootstrap_pmort <- readRDS(\"./model output/bootstrap_pmort.rds\")\n\n#order for variables to be plotted\nvar_names <- character()\nvar_names[1] <- \"Intercept\"\nvar_names[2] <- \"Neigh. Rat. (log)\"\nvar_names[3] <- \"ENN Dist (log)\"\nvar_names[4] <- \"4m BA (log)\"\nvar_names[5] <- \"Height\"\nvar_names[6] <- \"Diam (log)\"\nvar_names[7] <- \"4m BA : CWD\"\nvar_names[8] <- \"ENN Dist : Neigh. Rat.\"\n\nattr(bootstrap_pimo_int$t0, \"names\")\nattr(bootstrap_juos$t0, \"names\")\nattr(bootstrap_pmort$t0, \"names\")\n\n#manually select the order of variables to line up with the variable names\norder_p <- c(1, 9, 7, 5, 8, 6, 10)\norder_j <- c(1, 9, 7, 5, 8, 6, 10)\norder_pmort <- c(1, 9, 7, 5, 8, 6)\n\nopar <- par(no.readonly = TRUE)\n\npar(opar)\n\ntiff(filename=\"./plots/Figure_3_coefficient_density_plots.tif\", \n     type = \"cairo\",\n     antialias = \"gray\",\n     compression = \"lzw\",\n     units=\"in\", \n     width = 6, \n     height=4, \n     pointsize=15, \n     res=600)\n\npar(mar = c(1,1,1,0.6),\n    oma = c(1,5,0.2,0),\n    family = \"serif\")\n\nlayout(matrix(c(0,1,2,0,3,4,0,5,6,0,7,8,0,9,10,0,11,12,0,13,0,0,14,0,15,0,0), 9, 3, byrow = TRUE),\n       widths = rep(c(.3,2,1), times = 9),\n       heights = c(1.3,1,1,1,1,1,1,1))\n\n\n#loop over each variable\nfor (i in 1:length(var_names)){\n  \n  #pull out density plots for selected variables, controlled by the order_x lists defined above\n  if(i <= 6){\n    d_p <- density(bootstrap_pimo_int$t[ , order_p[i]])\n    d_j <- density(bootstrap_juos$t[, order_j[i]])\n    d_pm <- density(bootstrap_pmort$t[, order_pmort[i]])}\n  \n  #changing assignment for the interaction terms\n  if(i >= 7){\n    d_p <- density(bootstrap_pimo_int$t[ , order_p[7]])\n    d_j <- density(bootstrap_juos$t[, order_j[7]])\n  }\n  \n  if(i == 1){ #different axes for intercept\n    \n    #plot pinyon and juniper dieback density plots\n    plot(NA,\n         xlim = c(min(c(min(d_p$x), min(d_j$x))), max(c(max(d_p$x), max(d_j$x)))),\n         ylim = c(0,max(c(max(d_p$y), max(d_j$y)))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_p, col = \"grey50\") #pinyon in darker grey\n    polygon(d_p, col = addTrans(\"grey50\", 90))\n    lines(d_j, col = \"grey90\", new = FALSE) #juniper in lighter grey\n    polygon(d_j, col = addTrans(\"grey90\", 60))\n    axis(1)\n    \n    #label the row with the i'th value of the var_names vector\n    mtext(var_names[i],side=3,line=-1.8, \n          at=par(\"usr\")[1] - 3,\n          cex=.75,\n          adj = 1) #in this case, Intercept\n    \n    mtext(\"Canopy dieback\", side = 3, cex = 0.9) #title for left column\n    \n    \n    plot(NA,\n         xlim = c(min(d_pm$x), max(d_pm$x)),\n         ylim = c(min(d_pm$y), max(d_pm$y)),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_pm, col = \"blue\")\n    polygon(d_pm, col = addTrans(\"grey50\", 90))\n    axis(1)\n    \n    mtext(\"Pinyon mortality\", side = 3, cex = 0.9) #label for right column\n    \n  } \n  \n  \n  if(i > 1 & i <7){ #all other variables\n    \n    par(mar = c(0,0,1,0))\n    \n    plot(NA,\n         xlim = (c(-6,4)),\n         ylim = c(0,max(c(max(d_p$y), max(d_j$y)))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_p, col = \"black\")\n    polygon(d_p, col = addTrans(\"grey50\", 90))\n    lines(d_j, col = \"black\", new = FALSE)\n    polygon(d_j, col = addTrans(\"grey90\", 60))\n    axis(1, labels = FALSE)\n    # axis(2)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    mtext(var_names[i],side=3,line=-1.5, \n          at=par(\"usr\")[1] - .7,\n          cex=.75,\n          adj = 1) # label row with variable name\n    \n    \n    \n    par(mar = c(0,0.6,1,0))\n    \n    plot(NA,\n         xlim = c(-1,2),\n         ylim = c(min(d_pm$y), max(d_pm$y)),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_pm, col = \"blue\")\n    polygon(d_pm, col = addTrans(\"grey50\", 90))\n    axis(1, at = c(-1, 0, 1, 2), labels = FALSE)\n    \n    abline(v = 0, lwd = 2, lty = 2)\n    \n    if (i == 6){axis(1, at = c(-1, 0, 1, 2))}\n  }\n  \n  if(i == 7){ #interaction term for pinyon\n    par(mar = c(0,0,1,0))\n    \n    plot(NA,\n         xlim = (c(-6,4)),\n         ylim = c(0,(max(d_p$y))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_p, col = \"black\")\n    polygon(d_p, col = addTrans(\"grey50\", 90))\n    axis(1, labels = FALSE)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    mtext(var_names[7],side=3,line=-1.5, \n          at=par(\"usr\")[1] - .7,\n          cex=.75,\n          adj = 1)\n    \n  }\n  \n  if(i == 8){ #interaction term for juniper dieback\n    par(mar = c(0,0,1,0))\n    \n    plot(NA,\n         xlim = (c(-6,4)),\n         ylim = c(0,(max(d_j$y))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_j, col = \"black\")\n    polygon(d_j, col = addTrans(\"grey90\", 60))\n    axis(1, labels = FALSE)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    mtext(\"ENN Dist :\\nNeigh. Rat.\",side=3,line=-2.5, \n          at=par(\"usr\")[1] - .7,\n          cex=.75,\n          adj = 1)\n    \n    axis(1)\n  }\n  \n}\n\n\n\n\nmtext(text = \"Bootstrap coefficient estimates (scaled)\", side = 1,\n      line = 2.3, at = 0, cex = 0.9)\n\ndev.off()\n\n\n#####################################################################\n### Generate figure 2\n### multipanel figure\n#####################################################################\n## this is the ugliest, WETtest piece of code you've ever seen but it should work.\n## run this whole chunk until dev.off() way down there about 350 lines\npardefault <- par(no.readonly = T)\n\n\n# for unscaling variables -- these things come from a full model in the model set, you'll have to change\n# the number or the path depending upon what kind of model object and the order of your models, etc.\n# You can also just get them from the raw data.\nlibrary(lme4)\n\n\nall_tree_vars <- read.csv(\"./Clean data/all_tree_vars_scaled_and_transformed.csv\")\nall_tree_vars_trans <- read.csv(\"./Clean data/all_tree_vars_unscaled_trans.csv\")\nall_tree_vars_unscaled <- read.csv( \"./Clean data/all_tree_vars_unscaled_untrans.csv\")\n\nalldata <- read.csv(\"./Clean data/plot_level_vars_scaled.csv\")\n\nalldata_unscaled <- read.csv(\"./Clean data/plot_level_vars.csv\")\n\n\nBA_4m_mean <- mean((all_tree_vars_trans[all_tree_vars_trans$Spp == \"PIMO\", \"BA_4m_log\"]))\nBA_4m_sd <- sd((all_tree_vars_trans[all_tree_vars_trans$Spp == \"PIMO\", \"BA_4m_log\"]))\n\nENN_dist_mean <- mean((all_tree_vars_trans[all_tree_vars_trans$Spp == \"JUOS\", \"ENN_dist_log\"]))\nENN_dist_sd <- sd((all_tree_vars_trans[all_tree_vars_trans$Spp == \"JUOS\", \"ENN_dist_log\"]))\n\nNeighbor_larger_mean <- mean((all_tree_vars_trans[all_tree_vars_trans$Spp == \"JUOS\", \"Neighbor_larger_log\"]))\nNeighbor_larger_sd <- sd((all_tree_vars_trans[all_tree_vars_trans$Spp == \"JUOS\", \"Neighbor_larger_log\"]))\n\ncwd_normal_cum_mean <- mean(all_tree_vars_unscaled[all_tree_vars_unscaled$Spp == \"PIMO\", \"cwd_normal_cum\"])\ncwd_normal_cum_sd<- sd(all_tree_vars_unscaled[all_tree_vars_unscaled$Spp == \"PIMO\", \"cwd_normal_cum\"])\n\n\n\n#open device\n\ntiff(filename=\"./plots/Figure 2 interaction plots.tif\",\n     type=\"cairo\",\n     units=\"in\",\n     width = 6,\n     height = 6,\n     pointsize=15,\n     res=600,\n     compression = \"lzw\")\n\n\n\nlayout(matrix(c(1,2,3,4,5,6), nrow=2, ncol=3, byrow = TRUE))\npar(mar = c(3,.5,1.2,0), oma = c(2,4,1,1), family = \"serif\", bty = 'n', \n    cex = 0.7, cex.lab = 0.7, cex.axis = 0.7)\n\n#############################################################\n### Pimo part -- figure 4a\n#############################################################\n\nmodel <- readRDS(\"./model output/pimo_model.rds\")\n# \n# num_tree <- (nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]))\n# ranefs <- vector(mode = \"numeric\", length = num_tree) \n\n###BA_4meter\ncalculate_preds_BA_4m <- function(quant){\n  #set all terms = 0, which is their mean value because all variables are standardized\n  C <- data.frame(matrix(ncol = length(names(coef(model)$Cluster)), nrow = 1000))\n  C <- as.data.frame(apply(C, c(1,2), FUN = function(x){return(0)}))\n  names(C) <- names(coef(model)$Cluster)\n  C$\"(Intercept)\" <- 1\n  C$cwd_normal_cum <- unname(quantile(all_tree_vars$cwd_normal_cum, quant))\n  #min value calculated to correspond to a real BA of -.001\n  C$BA_4m_log <- seq(-1.068, max(subset(all_tree_vars, select = \"BA_4m_log\")), length.out = 1000)\n  C$\"cwd_normal_cum:BA_4m_log\" = C$cwd_normal_cum * C$BA_4m_log\n  \n  se <- vector(mode='numeric', length=nrow(C))\n  \n  for (i in 1:nrow(C)){\n    se[i] <- as.numeric(calc.se(C[i, ]))\n  }\n  \n  \n  preds <- data.frame(\n    predictions = as.matrix(C) %*% as.matrix(fixef(model)),\n    lo = as.matrix(C) %*% as.matrix(fixef(model)) - 1.96*se,\n    hi = as.matrix(C) %*% as.matrix(fixef(model)) + 1.96*se,\n    # BA_4m = model@frame$`BA_4m`,\n    BA_4m_sim = C$BA_4m_log,\n    BA_4m_sim_natural_scale = (exp((C$BA_4m_log * BA_4m_sd) + BA_4m_mean)/10000) # in m2\n  )\n  \n  return(preds)\n  \n}\n\ncalculate_partial_residuals_BA_4m <- function(quant){\n  model_frame <- model@frame\n  resids <- resid(model)\n  mod_matrix <- model.matrix(model)\n  fixed <- fixef(model)\n  \n  \n  if(quant == 0.1){\n    cwd_low <-  unname(quantile(all_tree_vars$cwd_normal_cum, 0))\n    cwd_high <-  unname(quantile(all_tree_vars$cwd_normal_cum, .30))\n  }\n  if(quant == 0.5){\n    cwd_low <-  unname(quantile(all_tree_vars$cwd_normal_cum, 0.3))\n    cwd_high <-  unname(quantile(all_tree_vars$cwd_normal_cum, .7))\n  }\n  if(quant == 0.9){\n    cwd_low <-  unname(quantile(all_tree_vars$cwd_normal_cum, 0.7))\n    cwd_high <-  unname(quantile(all_tree_vars$cwd_normal_cum, 1))\n  }\n  \n  select_data <- which(model_frame$cwd_normal_cum > cwd_low & model_frame$cwd_normal_cum < cwd_high)\n  \n  model_frame <- as.data.frame(model_frame[select_data, ])\n  resids <- resids[select_data]\n  mod_matrix <- mod_matrix[select_data, ]\n  ranefs <- vector(mode = \"numeric\", length = length(select_data))\n  \n  for (i in (1:length(select_data))){\n    j <- select_data[i]\n    ranefs[i] <- ranef(model)$site[rownames(ranef(model)$site) == paste(model@frame$site[j], model@frame$Cluster[j], sep=\":\"), ]\n  }\n  \n  B <- as.matrix(fixed[c(\"BA_4m_log\")])\n  X <- as.matrix(mod_matrix[, c(\"BA_4m_log\")])\n  \n  part_resids <- resids + t(B) %*% t(X) + fixed[\"(Intercept)\"] + ranefs \n  BA_4m <- mod_matrix[, \"BA_4m_log\"]\n  BA_4m_back_trans <- (exp((BA_4m * BA_4m_sd) + BA_4m_mean)/10000)\n  return(cbind(t(part_resids), BA_4m_back_trans))\n  \n}\n\nfor(i in 1:3){\n  values = c(0.1,0.5,0.9)\n  # Use the function to get all the stuff we need (predictions, partial residuals, and SEs)\n  pred <- calculate_preds_BA_4m(values[i])\n  #part_resids <- calculate_partial_residuals_BA_4m(values[i])\n  \n  \n  plot(NA,\n       ylim = c(-50, 10),\n       xlim = c(0.001, 3),\n       xlab = \"\",\n       ylab = \"\",\n       log = \"x\",\n       cex.lab = 1.5,\n       xaxt = \"n\",\n       yaxt = \"n\"\n  )\n  \n  #points(part_resids[, 1] ~ part_resids[, 2], pch = 21, col = \"grey70\", cex = 0.5)\n  \n  lines(pred$predictions ~ pred$BA_4m_sim_natural_scale, lwd = 2)\n  lines((pred$lo) ~ pred$BA_4m_sim_natural_scale, lwd = 1.3) \n  lines((pred$hi) ~ pred$BA_4m_sim_natural_scale, lwd = 1.3)\n  polygon(c(pred$BA_4m_sim_natural_scale, rev(pred$BA_4m_sim_natural_scale)), c((pred$hi), rev((pred$lo))),\n          col = addTrans(\"grey\",30), border = NA) #fills in the area between high and low confidence intervals\n  \n  \n  \n  text(x = 0.05, y = 5, labels = paste0(values[i]*100, \"% CWD = \\n\", \n                                         round(((unname(quantile(all_tree_vars$cwd_normal_cum, values[i])) * cwd_normal_cum_sd + cwd_normal_cum_mean)), 0), \" mm\"),\n       cex = 0.7)\n  \n  axis(1, at=c(0.001, 0.01, .1, 1))\n  \n  if(i == 1){\n    mtext(side = 3, at = 0.003, text= \"(a)\")\n    axis(2)\n    mtext(side = 2, text = \"Predicted Change in Canopy (%)\", cex = 0.7, outer = FALSE, line = 1.7)}\n  \n  #label x axis\n  if(i == 2){mtext(side = 1, text = expression(paste(\"BA, 4m buffer (\", m^2, \")\")), cex= 0.7, outer = FALSE, line = 2)}\n  \n}\n\n\n#######################################################\n### juos part -- figure 4b\n#######################################################\n\n\nmodel <- readRDS(\"./model output/juos_model.rds\")\n\n###BA_4meter\ncalculate_preds_Neighbor_larger <- function(quant){\n  #set all terms = 0, which is their mean value because all variables are standardized\n  C <- data.frame(matrix(ncol = length(names(coef(model)$Cluster)), nrow = 1000))\n  C <- as.data.frame(apply(C, c(1,2), FUN = function(x){return(0)}))\n  names(C) <- names(coef(model)$Cluster)\n  C$\"(Intercept)\" <- 1\n  C$ENN_dist_log <- unname(quantile(all_tree_vars$ENN_dist_log, quant))\n  #min value calculated to correspond to a real BA of -.001\n  C$Neighbor_larger_log <- minmax.sequence(all_tree_vars, \"Neighbor_larger_log\", 1000)\n  C$`ENN_dist_log:Neighbor_larger_log` = C$ENN_dist_log * C$Neighbor_larger_log\n  \n  se <- vector(mode='numeric', length=nrow(C))\n  \n  for (i in 1:nrow(C)){\n    se[i] <- as.numeric(calc.se(C[i, ]))\n  }\n  \n    preds <- data.frame(\n    predictions = as.matrix(C) %*% as.matrix(fixef(model)),\n    lo = as.matrix(C) %*% as.matrix(fixef(model)) - 1.96*se,\n    hi = as.matrix(C) %*% as.matrix(fixef(model)) + 1.96*se,\n    # BA_4m = model@frame$`BA_4m`,\n    Neighbor_larger_sim = C$Neighbor_larger_log,\n    Neighbor_larger_natural_scale = (exp((C$Neighbor_larger_log * Neighbor_larger_sd) + Neighbor_larger_mean))\n  )\n  \n  return(preds)\n  \n}\n\ncalculate_partial_residuals_NL <- function(quant){\n  model_frame <- model@frame\n  resids <- resid(model)\n  mod_matrix <- model.matrix(model)\n  fixed <- fixef(model)\n  \n  \n  if(quant == 0.1){\n    enn_low <-  unname(quantile(all_tree_vars$ENN_dist_log, 0))\n    enn_high <-  unname(quantile(all_tree_vars$ENN_dist_log, .30))\n  }\n  if(quant == 0.5){\n    enn_low <-  unname(quantile(all_tree_vars$ENN_dist_log, 0.3))\n    enn_high <-  unname(quantile(all_tree_vars$ENN_dist_log, .7))\n  }\n  if(quant == 0.9){\n    enn_low <-  unname(quantile(all_tree_vars$ENN_dist_log, 0.7))\n    enn_high <-  unname(quantile(all_tree_vars$ENN_dist_log, 1))\n  }\n  \n  select_data <- which(model_frame$ENN_dist_log > enn_low & model_frame$ENN_dist_log < enn_high)\n  \n  model_frame <- as.data.frame(model_frame[select_data, ])\n  resids <- resids[select_data]\n  mod_matrix <- mod_matrix[select_data, ]\n  ranefs <- vector(mode = \"numeric\", length = length(select_data))\n  \n  for (i in (1:length(select_data))){\n    j <- select_data[i]\n    ranefs[i] <- ranef(model)$site[rownames(ranef(model)$site) == paste(model@frame$site[j], model@frame$Cluster[j], sep=\":\"), ]\n  }\n  \n  B <- as.matrix(fixed[c(\"Neighbor_larger_log\")])\n  X <- as.matrix(mod_matrix[, c(\"Neighbor_larger_log\")])\n  \n  part_resids <- resids + t(B) %*% t(X) + fixed[\"(Intercept)\"] + ranefs \n  NL <- mod_matrix[, \"Neighbor_larger_log\"]\n  NL_back_trans <- (exp((NL * Neighbor_larger_sd) + Neighbor_larger_mean))\n  return(cbind(t(part_resids), NL_back_trans))\n  \n}\n\ni <- 1\nfor(i in 1:3){\n  values = c(0.1,0.5,0.9)\n  # Use the function to get all the stuff we need (predictions, partial residuals, and SEs)\n  pred <- calculate_preds_Neighbor_larger(values[i])\n  \n  #part_resids <- calculate_partial_residuals_NL(values[i])\n  \n  plot(NA,\n       ylim = c(-25, 10),\n       xlim = c(min(pred$Neighbor_larger_natural_scale), max(pred$Neighbor_larger_natural_scale)),\n       xlab = \"\",\n       ylab = \"\",\n       log = \"x\",\n       cex.lab = 1.5,\n       xaxt = \"n\",\n       yaxt = \"n\"\n  )\n  #points(part_resids[, 1] ~ part_resids[, 2], pch = 21, col = \"grey70\", cex = 0.5)\n  \n  lines(pred$predictions ~ I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), lwd = 2)\n  lines((pred$lo) ~ I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), lwd = 1.3) \n  lines((pred$hi) ~ I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), lwd = 1.3)\n  polygon(c(I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), rev(I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)))), c((pred$hi), rev((pred$lo))),\n          col = addTrans(\"grey\",30), border = NA) #fills in the area between high and low confidence intervals\n  \n  axis(1, at=c(0.001,.1, 10), labels = c(.001, .1, 10))\n  \n  text(x = 0.9, y = 5, labels = paste0(values[i]*100, \"% ENN Distance = \\n\", \n                                        round(exp((unname(quantile(all_tree_vars$ENN_dist, values[i])) * ENN_dist_sd + ENN_dist_mean)), 1), \" m\"),\n       cex = 0.7)\n  \n  \n  if(i == 1){\n    mtext(side = 3, at = 0.003, text= \"(b)\")\n    axis(2)\n    mtext(side = 2, text = \"Predicted Change in Canopy (%)\", cex = 0.7, outer = FALSE, line = 1.7)}\n  \n  #label x axis\n  if(i == 2){mtext(side = 1, text = \"Neighbor Size Ratio (log)\", cex= 0.7, outer = FALSE, line = 2)}\n  \n}\n\ndev.off()\n\npar <- pardefault\n\n\n#-------------------------------------------------------------------------------------------\n# Cwd effects plot\n#-------------------------------------------------------------------------------------------\n\ntiff(filename=\"./plots/Figure X plot-level cwd effect plot.tif\",\n     type=\"cairo\",\n     units=\"in\",\n     width = 4,\n     height = 3,\n     pointsize=15,\n     res=600,\n     compression = \"lzw\")\n\npar(mar = c(3,.5,1.2,0), oma = c(2,4,1,1), family = \"serif\", bty = 'n', \n    cex = 0.7, cex.lab = 0.7, cex.axis = 0.7)\n\n\n### set some parameters to be use throughout\nymax <- 20\nymin <- -80\n\n# model used for effects plot\nmodel <- readRDS(\"./model output/plot_model.rds\")\n\n# ranefs <- vector(mode = \"numeric\", length = 98) #initialize a vector for the ranefs\n#\n# #pull out the random intercept for each plot\n# for (i in (1:98)){\n#   ranefs[i] <- ranef(model)$Cluster[rownames(ranef(model)$Cluster) == model@frame$Cluster[i], ]\n# }\n\n#set all terms = 0, which is their mean value because all variables are standardized\nC <- data.frame(matrix(ncol = length(names(coef(model)$Cluster)), nrow = 1000))\nC <- as.data.frame(apply(C, c(1,2), FUN = function(x){return(0)}))\nnames(C) <- names(coef(model)$Cluster)\nC$\"(Intercept)\" <- 1\nC$cwd_normal_cum <- minmax.sequence(alldata, \"cwd_normal_cum\", nrow(C))\n\nse <- vector(mode='numeric', length=nrow(C))\n\nfor (i in 1:nrow(C)){\n  se[i] <- as.numeric(calc.se(C[i, ]))\n}\n\npred <- data.frame(\n  predictions = as.matrix(C) %*% as.matrix(fixef(model)),\n  lo = as.matrix(C) %*% as.matrix(fixef(model)) - 1.96*se,\n  hi = as.matrix(C) %*% as.matrix(fixef(model)) + 1.96*se,\n  cwd_normal_cum_sim = C$cwd_normal_cum\n)\ncwd_normal_cum_orig = ((model@frame$cwd_normal_cum * cwd_normal_cum_sd) + cwd_normal_cum_mean)\npart_resids = model@frame$Avg_delta_pdc\n#set up the empty plot window\nplot(NA,\n     ylim = c(ymin, ymax),\n     xlim = c((min(cwd_normal_cum_orig)), max(cwd_normal_cum_orig)),\n     xlab = \"\",\n     ylab = \"\",\n     # log = \"x\",\n     cex.lab = 1,\n     xaxt = \"n\",\n     yaxt = \"n\"\n)\n\npoints(part_resids ~ cwd_normal_cum_orig, pch = 20, cex = 1, col = \"grey70\")\n#draw prediction line and confidence envelope of predictions\nlines(pred$predictions ~ I(((pred$cwd_normal_cum_sim * cwd_normal_cum_sd) + cwd_normal_cum_mean)), lwd = 2)\nlines((pred$lo) ~ I(((pred$cwd_normal_cum_sim * cwd_normal_cum_sd) + cwd_normal_cum_mean)), lwd = 1.3)\nlines((pred$hi) ~ I(((pred$cwd_normal_cum_sim * cwd_normal_cum_sd) + cwd_normal_cum_mean)), lwd = 1.3)\n\n#fill in the confidence envelope\npolygon(c(I((pred$cwd_normal_cum_sim * cwd_normal_cum_sd) + cwd_normal_cum_mean), rev(I((pred$cwd_normal_cum_sim * cwd_normal_cum_sd) + cwd_normal_cum_mean))), c((pred$hi), rev((pred$lo))),\n        col = addTrans(\"grey\",30), border = NA)\n\n#label the levels of the interacting variable\n\naxis(1, cex.axis = 1) #draw the x-axis\naxis(2, cex.axis = 1)\n\nmtext(side = 2, text = \"Mean change in canopy (%)\", cex = 0.7, outer = FALSE, line = 2.5)\nmtext(side = 1, text = \"Normal annual\\nclimatic water deficit (mm)\", cex = 0.7, outer = FALSE, line = 2.8)\n\ndev.off()\n",
    "created" : 1508885851964.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1398993436",
    "id" : "414F5E16",
    "lastKnownWriteTime" : 1508891411,
    "last_content_update" : 1508891411119,
    "path" : "C:/Users/Sam/Google Drive/Projects/MS Thesis/Flake and Weisberg PJ mortality analysis/ind_tree_analysis_figure_code_101917.R",
    "project_path" : "ind_tree_analysis_figure_code_101917.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}