{
    "collab_server" : "",
    "contents" : "#### Analysis of field data\n# Sam Flake, 12 Sep 2017\n# sflake@gmail.com or swflake@ncsu.edu\n\n\n# load libraries\nlibrary(plyr)\nlibrary(boot)\nlibrary(lme4)\nlibrary(MuMIn)\nlibrary(car)\nlibrary(effects)\nlibrary(pscl)\nlibrary(\"pROC\")\n\n## set up some options\nset.seed(665224291)\noptions(na.action = na.fail)\npardefault <- par(no.readonly = T)\n\n#Source some useful functions\nsource(\"pj_mortality_functions_090617.R\")\n\n#read prepared data\nall_tree_vars <- read.csv(\"./Clean data/all_tree_Vars_scaled_and_transformed.csv\")\nall_tree_vars_orig <- read.csv(\"./Clean data/all_tree_Vars_unscaled_untrans.csv\")\n\n#--------------------------------------------------------------------------------------------\n# tree-level models\n\n#global model with tree-level vars and abiotic vars\npimo_global <- lmer(formula = Delta_pdc ~ Neighbor_larger_log + ENN_dist_log + Diam_log + Height + BA_4m_log +  \n                          cwd_normal_cum + fdsi_anom +\n                          cwd_peak_anom + tmean + ppt +\n                          vpd_normal_annual_max + vpd_peak_anom + avg_summer_tmax +\n                          peak_tmax + min_ann_ppt +\n                          Pndjfm + Avg_depth + AWC +\n                          (1|Cluster/site), \n                      data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ],\n                    na.action = na.fail)\n\n#only use combos that aren't pairwise correlated\ncormat <- abs(cor(all_tree_vars[all_tree_vars$Spp == \"PIMO\", c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log', \n                                                               'cwd_normal_cum', 'fdsi_anom',\n                                                                   'cwd_peak_anom' , 'tmean', 'ppt',\n                                                                   'vpd_normal_annual_max' , 'vpd_peak_anom' , 'avg_summer_tmax', 'peak_tmax',\n                                                                   'min_ann_ppt',  'Pndjfm' , 'Avg_depth' , 'AWC')])) <=.5\n\n#use all tree-level vars\ncormat[1:5,1:5] <- TRUE\n\n#use only one side of matrix (avoid duplicated models)\ncormat[!lower.tri(cormat)] <- NA\n\n#find all combinations with a few given conditions: \n# abiotic variables can change but stand structure variables are fixed;\n# abiotic variables with correlations greater than .5 are not allowed;\n# 9 maximum variables are allowed;\n# progress is displayed in console\n\n# this only takes a minute or two\npimo_dredge <- dredge(pimo_global, \n                      fixed = c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log'),\n                      subset = cormat, \n                      m.lim = c(5, 8), \n                      trace = 2)\n\n#get call for top model and evaluate it\nbest_pimo_call <- as.character(unlist(attr((pimo_dredge)[1], \"model.calls\")))\npimo_model_dredge <- eval(parse(text = best_pimo_call))\nsummary(pimo_model_dredge)\n\npimo_dredge[1:10] #top 10 models\n\n# #----------------------------------------------\n# \n\n#global model with tree-level vars and abiotic vars\njuos_global <- lmer(formula = Delta_pdc ~ Neighbor_larger_log + ENN_dist_log + Diam_log + Height + BA_4m_log +  \n                      cwd_normal_cum + fdsi_anom +\n                      cwd_peak_anom + tmean + ppt +\n                      vpd_normal_annual_max + vpd_peak_anom + avg_summer_tmax +\n                      peak_tmax + min_ann_ppt +\n                      Pndjfm + Avg_depth + AWC +\n                      (1|Cluster/site), \n                    data = all_tree_vars[all_tree_vars$Spp == \"JUOS\", ],\n                    na.action = na.fail)\n\n#only use combos that aren't pairwise correlated\ncormat <- abs(cor(all_tree_vars[all_tree_vars$Spp == \"JUOS\", c('Neighbor_larger', 'ENN_dist', 'Height', 'Diam', 'BA_4m', \n                                                               'cwd_normal_cum', 'fdsi_anom',\n                                                               'cwd_peak_anom' , 'tmean', 'ppt',\n                                                               'vpd_normal_annual_max' , 'vpd_peak_anom' , 'avg_summer_tmax', 'peak_tmax',\n                                                               'min_ann_ppt',  'Pndjfm' , 'Avg_depth' , 'AWC')])) <=.5\n\n#use all tree-level vars\ncormat[1:5,1:5] <- TRUE\n\n#use only one side of matrix (avoid duplicated models)\ncormat[!lower.tri(cormat)] <- NA\n\n#find all combinations\njuos_dredge <- dredge(juos_global, \n                      fixed = c('Neighbor_larger', 'ENN_dist', 'Height', 'Diam', 'BA_4m'),\n                      subset = cormat, \n                      m.lim = c(5, 8), \n                      trace = 2)\n\n\n#get call for top model and evaluate it\nbest_juos_call <- as.character(unlist(attr((juos_dredge)[1], \"model.calls\")))\njuos_model_dredge <- eval(parse(text = best_juos_call))\n\n\n# \n# ###################################\n# # PIMO mortality\n# ###################################\npmort_global <- glmer(formula = Died ~ Neighbor_larger_log + ENN_dist_log + Diam_log + Height + BA_4m_log +  \n                        cwd_normal_cum + fdsi_anom +\n                        cwd_peak_anom + tmean + ppt +\n                        vpd_normal_annual_max + vpd_peak_anom + avg_summer_tmax +\n                        peak_tmax + min_ann_ppt +\n                        Pndjfm + Avg_depth + AWC +\n                      (1|site), family = \"binomial\",\n                      data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ], na.action = na.fail)\n\n#only use combos that aren't pairwise correlated\ncormat <- abs(cor(all_tree_vars[all_tree_vars$Spp == \"PIMO\", c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log', \n                                                               'cwd_normal_cum', 'fdsi_anom',\n                                                               'cwd_peak_anom' , 'tmean', 'ppt',\n                                                               'vpd_normal_annual_max' , 'vpd_peak_anom' , 'avg_summer_tmax', 'peak_tmax',\n                                                               'min_ann_ppt',  'Pndjfm' , 'Avg_depth' , 'AWC')])) <=.5\n\n#use all tree-level vars\ncormat[1:5,1:5] <- TRUE\n\n#use only one side of matrix (avoid duplicated models)\ncormat[!lower.tri(cormat)] <- NA\n\n# find all combinations with a few given conditions: \n# abiotic variables can change but stand structure variables are fixed;\n# abiotic variables with correlations greater than .5 are not allowed;\n# 8 maximum variables are allowed;\n# progress is displayed in console\n\n# this only takes a half an hour or so\nstart.time <- Sys.time()\npmort_dredge <- dredge(pmort_global, \n                      fixed = c('Neighbor_larger_log', 'ENN_dist_log', 'Diam_log', 'Height', 'BA_4m_log'),\n                      subset = cormat, \n                      m.lim = c(5, 8), \n                      trace = 2)\nend.time <- Sys.time()\n\ntime.taken_pmort_dredge <- end.time - start.time\ntime.taken_pmort_dredge #30 minutes\n(pmort_dredge)[c(1:10)]\n\n#get call for top model and evaluate it\nbest_pmort_call <- as.character(unlist(attr((pmort_dredge)[1], \"model.calls\")))\npmort_model_dredge <- eval(parse(text = best_pmort_call))\n\n\n#############################################################################################\n#Tree-level models\n#############################################################################################\n\n#PIMO dieback\n\n#add interaction term to the PIMO dieback model\npimo_int_ba <- update(pimo_model_dredge, . ~ . + BA_4m_log:cwd_normal_cum)\n\nsummary(pimo_int_ba)\n\nAICc(pimo_model_dredge) - AICc(pimo_int_ba) #improves AICc by 3.8\n\n#nonparametric bootstrap cis\nbs <- function(formula, data, indices) {\n  d <- data[indices,] # allows boot to select sample \n  fit <- lmer(formula, data=d)\n  return(fixef(fit)) \n} \n\nbs(formula = pimo_int_ba@call,\n   data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n\n# bootstrapping with 5000 replications\n#this takes a while (~6 hrs on an i7 3.4 Ghz processor. Would be faster with multithreading)\nstart.time <- Sys.time()\nbootstrap_pimo_int <- boot(data=all_tree_vars[all_tree_vars$Spp == \"PIMO\", ], \n                                statistic=bs, \n                                R=5000, \n                                formula= pimo_int_ba@call,\n                                parallel = \"no\")\nend.time <- Sys.time()\ntime.taken_pimo <- end.time - start.time\ntime.taken_pimo\n\nsaveRDS(bootstrap_pimo_int, file = paste0(\"./model output/bootstrap_pimo_int\", Sys.Date(), \".rds\"))\n\n# view results\nbootstrap_pimo <- bootstrap_pimo_int\nsummary(bootstrap_pimo)\nplot(bootstrap_pimo, index=1) # intercept\nplot(bootstrap_pimo, index=2) #\nplot(bootstrap_pimo, index=3) #\n\n# get 95% confidence intervals \nci_pimo <- cbind(attr(bootstrap_pimo_int$t0, \"names\"), summary(bootstrap_pimo_int))\nci_pimo$lo <- NA\nci_pimo$hi <- NA\n\nfor( i in 1:nrow(ci_pimo)){\n  ci_boot <- boot.ci(bootstrap_pimo_int, type = \"bca\", index = i)\n  #extract low and hi, add to ci_pimo df\n  ci_pimo$lo[i] <- ci_boot$bca[1,4]\n  ci_pimo$hi[i] <- ci_boot$bca[1,5]\n  ci_pimo$mean[i] <- mean(bootstrap_pimo_int$t[, i])\n}\n\nsaveRDS(ci_pimo, file = \"./model output/ci_pimo.rds\")\nwrite.csv(ci_pimo, \"./model output/ci_pimo.csv\")\n\n# plot(allEffects(pimo_model))\n#    plot(Effect(focal.predictors = c(\"ENN_dist\", \"Neighbor_larger\"), mod = pimo_model, \n#                ylim = c(-40, 0), partial.residuals = TRUE))\n#    plot(Effect(focal.predictors = c(\"BA_4m\", \"cwd_normal_cum\"), mod = pimo_int_ba, \n#                ylim = c(-40, 0), partial.residuals = TRUE))\n# coefplot2::coefplot2(pimo_model)\n# AICc(pimo_model)\n# vif.mer(pimo_model)\n# r.squaredGLMM(pimo_int_ba)\n# \n# plot(resid(pimo_int_ba) ~ predict(pimo_int_ba))\n# abline(h=0)\n# hist(resid(pimo_int_ba))\n# mse <- sum(resid(pimo_int_ba)^2)*(1 / length(resid(pimo_int_ba)))\n# \n# \n# qqmath(ranef(pimo_model, postVar = TRUE))\n\n#--------------------------------------------------------------\n\n# add interaction to the selected model\njuos_int_enn <- update(juos_model_dredge, . ~ . + ENN_dist:Neighbor_larger)\n\nbs(formula = juos_int_enn@call,\n   data = all_tree_vars[all_tree_vars$Spp == \"JUOS\", ])\n\n# bootstrapping with 5000 replications\n#this takes a while (~3.5 hrs on an i7 3.4 Ghz processor. Would be faster with multithreading)\nstart.time <- Sys.time()\nbootstrap_juos <- boot(data=all_tree_vars[all_tree_vars$Spp == \"JUOS\", ], \n                       statistic=bs, \n                       R=5000, \n                       formula=juos_int_enn@call)\n\n\nend.time <- Sys.time()\ntime.taken_juos <- end.time - start.time\ntime.taken_juos\n\nsaveRDS(bootstrap_juos, file = \"./model output/bootstrap_juos.rds\")\n\n# view results\n# bootstrap_juos\n# summary(bootstrap_juos)\n# plot(bootstrap_juos, index=1) # intercept \n# plot(bootstrap_juos, index=2) # \n# plot(bootstrap_juos, index=3) # \n# plot(bootstrap_juos, index=4) # \n# plot(bootstrap_juos, index=5) # \n# plot(bootstrap_juos, index=6) # \n# plot(bootstrap_juos, index=7) # \n# plot(bootstrap_juos, index=8) # \n# plot(bootstrap_juos, index=9) # \n# plot(bootstrap_juos, index=10) # \n\n# get 95% confidence intervals \nci_juos <- cbind(attr(bootstrap_juos$t0, \"names\"), summary(bootstrap_juos))\nci_juos$lo <- NA\nci_juos$hi <- NA\n\nfor( i in 1:nrow(ci_juos)){\n  ci_boot <- boot.ci(bootstrap_juos, type = \"bca\", index = i)\n  #extract low and hi, add to ci_pimo df\n  ci_juos$lo[i] <- ci_boot$bca[1,4]\n  ci_juos$hi[i] <- ci_boot$bca[1,5]\n  ci_juos$mean[i] <- mean(bootstrap_juos$t[, i])\n}\n\nsaveRDS(ci_juos, file = \"./model output/ci_juos.rds\")\n\nwrite.csv(ci_juos, \"./model output/ci_juos.csv\")\n\n# plot(allEffects(juos_model))\n#   plot(Effect(focal.predictors = c(\"ENN_dist\", \"Neighbor_larger\"), mod = juos_model, partial.residuals = TRUE), ylim = c(-20, 0))\n#   coefplot2::coefplot2(juos_model)\n#   AICc(juos_model)\n#   vif.mer(juos_model)\n#   r.squaredGLMM(juos_int_enn)\n#   \n#   plot(resid(juos_int_enn) ~ predict(juos_int_enn))\n#   abline(h = 0)\n#   hist(resid(juos_int_enn))\n#   mse <- sum(resid(juos_int_enn)^2)*(1 / length(resid(juos_int_enn)))\n\n#####################################\n# Below here is PIMO mortality stuff\n## PIMO mortality\n\n#full model\np_mort <- pmort_model_dredge\n  ## scale the gradient by the hessian to get relative gradient, \n  # see Bolker comments at https://github.com/lme4/lme4/issues/120\n  relgrad <- with(p_mort@optinfo$derivs,solve(Hessian,gradient))\n  max(abs(relgrad))\n  #looks good!\n\n# plot(inv.logit(resid(p_mort)) ~ inv.logit(predict(p_mort)))\n\n\n# bootstrapping with 5000 replications\n#this takes a while (1.1 days on an i7 3.4 Ghz processor. Would be faster with multithreading)\n\nbs <- function(formula, data, indices) {\n  d <- data[indices,] # allows boot to select sample \n  fit <- glmer(formula, data=d, nAGQ = 1, family = \"binomial\")\n  return(fixef(fit)) \n} \nstart.time <- Sys.time()\nbootstrap_pmort <- boot(data=all_tree_vars[all_tree_vars$Spp == \"PIMO\", ], \n                       statistic=bs, \n                       R=5000, \n                       formula = p_mort@call)\nend.time <- Sys.time()\ntime.taken_pmort <- end.time - start.time\ntime.taken_pmort\n\nsaveRDS(bootstrap_pmort, file = \"./model output/bootstrap_pmort.rds\")\n\n# view results\n# # view results\n# bootstrap_pmort\n# summary(bootstrap_pmort)\n# plot(bootstrap_pmort, index=1) # intercept x\n# plot(bootstrap_pmort, index=2) #\n# plot(bootstrap_pmort, index=3) #\n# plot(bootstrap_pmort, index=4) #\n# plot(bootstrap_pmort, index=5) #\n# plot(bootstrap_pmort, index=6) #\n# plot(bootstrap_pmort, index=7) #\n# plot(bootstrap_pmort, index=8) #\n# plot(bootstrap_pmort, index=9) #\n# plot(bootstrap_pmort, index=10) #\n\n# get 95% confidence intervals \nci_pmort <- cbind(attr(bootstrap_pmort$t0, \"names\"), summary(bootstrap_pmort))\nci_pmort$lo <- NA\nci_pmort$hi <- NA\n\nfor( i in 1:nrow(ci_pmort)){\n  ci_boot <- boot.ci(bootstrap_pmort, type = \"bca\", index = i)\n  #extract low and hi, add to ci_pimo df\n  ci_pmort$lo[i] <- ci_boot$bca[1,4]\n  ci_pmort$hi[i] <- ci_boot$bca[1,5]\n  ci_pmort$mean[i] <- mean(bootstrap_pmort$t[, i])\n}\n\nsaveRDS(ci_pmort, file = \"./model output/ci_pmort.rds\")\n\nwrite.csv(ci_pmort, \"./model output/ci_pmort.csv\")\n\n\n##############################################\n# Does PDC predict mortality?\n# hist(all_tree_vars$PDC05)\n\n# #only climate vars\np_mort_clim <- glmer(Died ~\n                       Avg_depth + cwd_normal_cum + fdsi_anom + (1| site), nAGQ = 1, family = \"binomial\",\n                     data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\nsummary(p_mort_clim)\nplot(allEffects(p_mort_clim))\ncoefplot2::coefplot2(p_mort_clim)\nAICc(p_mort_clim)\nvif.mer(p_mort_clim)\nr.squaredGLMM(p_mort_clim)\n\n#only stand structure vars\np_mort_stand <- glmer(Died ~ ENN_dist + Neighbor_larger + BA_4m +\n                  (1|Cluster/site), nAGQ = 1, family = \"binomial\",\n                data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\nsummary(p_mort_stand)\nplot(allEffects(p_mort_stand))\ncoefplot2::coefplot2(p_mort_stand)\nAICc(p_mort_stand)\nvif.mer(p_mort_stand)\nr.squaredGLMM(p_mort_stand)\n\n\n\n#only tree-level vars\np_mort_tree <- glmer(Died ~ Height + Diam +\n                        (1|Cluster/site), nAGQ = 1, family = \"binomial\",\n                      data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\nsummary(p_mort_tree)\nplot(allEffects(p_mort_tree))\ncoefplot2::coefplot2(p_mort_tree)\nAICc(p_mort_tree)\nvif.mer(p_mort_tree)\nr.squaredGLMM(p_mort_tree)\n\n\n\n#intercept-only model\np_mort_int <- glm(Died ~ 1, family = \"binomial\",\n                  data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n\n# random effects only model\np_mort_int_mix <- glmer(Died ~ 1 + (1| site), nAGQ = 1, family = \"binomial\",\n                        data = all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n\n## Testing effect of different forms of PDC05 (percent dead crown in 2005)\n\npdc_mort <- update(p_mort, . ~ . + PDC05)\nrelgrad <- with(pdc_mort@optinfo$derivs,solve(Hessian,gradient))\nmax(abs(relgrad))\nplot(allEffects(pdc_mort))\n\npdc_mort_poly <- update(p_mort, . ~ . + poly(PDC05, 2))\nrelgrad <- with(pdc_mort_poly@optinfo$derivs,solve(Hessian,gradient))\nmax(abs(relgrad))\nplot(allEffects(pdc_mort_poly))\n\npdc_mort_exp <- update(p_mort, . ~ . + exp(PDC05))\nrelgrad <- with(pdc_mort_exp@optinfo$derivs,solve(Hessian,gradient))\nmax(abs(relgrad))\n\n#these  models aren't great but close enough to be useful, I think\n\n\n## Model comparisons\nAICc(p_mort)\nAICc(p_mort_clim)\nAICc(p_mort_stand)\nAICc(p_mort_tree)\nAICc(p_mort_int)\nAICc(p_mort_int_mix)\n\nAICc(pdc_mort)\nAICc(pdc_mort_poly)\nAICc(pdc_mort_exp)\n\nr.squaredGLMM(p_mort)\nr.squaredGLMM(p_mort_clim)\nr.squaredGLMM(p_mort_stand)\nr.squaredGLMM(p_mort_tree)\npR2(p_mort_int)\nr.squaredGLMM(p_mort_int_mix)\n\n\nr.squaredGLMM(pdc_mort)\nr.squaredGLMM(pdc_mort_poly)\nr.squaredGLMM(pdc_mort_exp)\n\n# hists and confusion matrices; not finished\nhist(fitted(p_mort)[all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"Y\"])\nhist(fitted(p_mort)[all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"N\"])\nhist(fitted(p_mort)[which(all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"Y\")])\nhist(fitted(p_mort)[which(all_tree_vars$Spp == \"PIMO\" & all_tree_vars$Died == \"N\")])\n\n######################################################\n#Plot the ROCs, adding the AUC for each\n######################################################\ntiff(filename=\"./plots/roc_plots.tiff\", \n    type=\"cairo\",\n    units=\"in\", \n    width = 8, \n    height=8, \n    pointsize=15, \n    res=160)\n\npar(mar = c(5.1, 4.1, 2.1, 2.1))\n\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(p_mort_int),print.auc = TRUE, \n         col = \"green\", lty = 2)\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(p_mort_int_mix),print.auc = TRUE,\n         add = TRUE, col = \"violet\", lty = 4, print.auc.y = 0.45)\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(p_mort),print.auc = TRUE,\n         add = TRUE, col = \"black\", print.auc.y = 0.4)\nplot.roc(all_tree_vars[all_tree_vars$Spp == \"PIMO\", \"Died\"],fitted(pdc_mort_poly),add = TRUE,\n         print.auc = TRUE, lty = 5, col = \"blue\", print.auc.y = 0.35)\nlegend(\"bottomright\", legend = c(\"Fixed Intercept\", \"Random Intercepts\", \"Full Model\", \"Full Model with PDC\"),\n       col = c(\"green\", \"violet\", \"black\", \"blue\"), \n       lty = c(2, 4, 1, 5),\n       lwd = 2,\n       cex = 1)\n\ndev.off()\n\n\n#########################\n## Classification accuracy\n########################\n\n#calculate classification accuracy for a given threshold\nclass_acc <- function(mod, thresh = .5){\n  con <- data.frame(fitted(mod), as.factor(all_tree_vars$Died[all_tree_vars$Spp == \"PIMO\"]))\n  nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])\n  true_pos <- nrow((con[con[, 1] > thresh & con[, 2] == \"Y\", ]))\n  false_pos <- nrow((con[con[, 1] > thresh & con[, 2] == \"N\", ]))\n  true_neg <- nrow((con[con[, 1] < thresh & con[, 2] == \"N\", ]))\n  false_neg <- nrow((con[con[, 1] < thresh & con[, 2] == \"Y\", ]))\n  accuracy <- (true_pos + true_neg) / length(fitted(mod))\n  return(accuracy)\n}\n\n\n# \n# class_acc(p_mort, .5)\n# class_acc(p_mort_clim, .5)\n# class_acc(p_mort_stand, .5)\n# class_acc(p_mort_tree, .5)\n# class_acc(p_mort_int, .5)\n# class_acc(p_mort_int_mix, .5)\n# \n# class_acc(pdc_mort, .5)\n# class_acc(pdc_mort_poly, .5)\n# class_acc(pdc_mort_exp, .5)\n\n\nca_pmort <- NA\nfor(i in 1:100){\n  ca_pmort[i] <- class_acc(p_mort, thresh = i / 100)\n}\nca_pmort_clim <- NA\nfor(i in 1:100){\n  ca_pmort_clim[i] <- class_acc(p_mort_clim, thresh = i / 100)\n}\nca_pmort_pdc_poly <- NA\nfor(i in 1:100){\n  ca_pmort_pdc_poly[i] <- class_acc(pdc_mort_poly, thresh = i / 100)\n}\nca_pmort_int <- NA\nfor(i in 1:100){\n  ca_pmort_int[i] <- class_acc(p_mort_int, thresh = i / 100)\n}\nca_pmort_int_mix <- NA\nfor(i in 1:100){\n  ca_pmort_int_mix[i] <- class_acc(p_mort_int_mix, thresh = i / 100)\n}\n\n## Plot of classification accuracy ~ threshold\ntiff(filename=\"./plots/classification_accuracy.tif\", \n    type = \"cairo\",\n    antialias = \"gray\",\n    compression = \"lzw\",\n    units=\"in\", \n    width = 8, \n    height=7, \n    pointsize=15, \n    res=600)\n\npar(mar = c(5.1, 4.1, 2.1, 2.1))\n\nplot(NA,\n     xlim = c(0, 100),\n     ylim = c(0, 1),\n     xlab = \"Threshold\",\n     ylab = \"Classification Accuracy\",\n     xaxt = 'n',\n     yaxt = 'n',\n     cex = 1.7)\nlines(ca_pmort_int, lty = 2, lwd = 2, col = \"green\")\nlines(ca_pmort_int_mix, lty = 4, lwd = 2, col = \"violet\")\nlines(ca_pmort, lwd = 2, col = \"black\")\nlines(ca_pmort_pdc_poly, lwd = 2, lty = 5, col = \"blue\")\naxis(side = 1, at = c(0, 20, 40, 60, 80, 100), tick = TRUE,\n     labels = c(\"0.00\", \"0.20\", \"0.40\", \"0.60\", \"0.80\", \"1.00\"))\naxis(side = 2, at = c(0, .2, .4, .6, .8, 1), tick = TRUE,\n     labels = c(\"0.00\", \"0.20\", \"0.40\", \"0.60\", \"0.80\", \"1.00\"))\nlegend(\"bottomright\", legend = c(\"Fixed Intercept\", \"Random Intercepts\", \"Full Model\", \"Full Model with PDC\"),\n       col = c(\"green\", \"violet\", \"black\", \"blue\"), \n       lty = c(2, 4, 1, 5),\n       lwd = 2,\n       cex = 1.2)\n\ndev.off()\n\n\n###############################################################\n#### Generate figure 5\n###############################################################\n\n####partial effect plot of 2005 PDC on mortality risk 2005-2015\n\nminx <- -mean(all_tree_vars_orig$PDC05)/sd(all_tree_vars_orig$PDC05)\nmaxx <- (95-mean(all_tree_vars_orig$PDC05))/sd(all_tree_vars_orig$PDC05)\n\n#PDC05 effect from model\nmort_eff <- Effect(pdc_mort_poly, focal.predictors = c(\"PDC05\"), xlevels = list(PDC05 = seq(minx,maxx,length.out = 100)))\n\n#prediction and 1-se envelope\nx <- unlist(mort_eff$x)*sd(all_tree_vars_orig$PDC05) + mean(all_tree_vars_orig$PDC05) #unscale x variable\nup <- exp(unlist(mort_eff$fit) + (mort_eff$se))\nlow <- exp(unlist(mort_eff$fit) - (mort_eff$se))\ny <- exp(unlist(mort_eff$fit))\n\ntiff(filename=\"./plots/pdc_mort_effects.tif\", \n    type = \"cairo\",\n    antialias = \"gray\",\n    compression = \"lzw\",\n    units=\"in\", \n    width = 3, \n    height=3, \n    pointsize=15, \n    res=600)\n\npar(mar = c(2.5,2.5,0.2,0.2),\n    oma = c(1,1,0.2,0.2),\n    family = \"serif\")\n\nplot(y ~ x, \n     ylim = c(0, 0.3),\n     xlim = c(0, 100),\n     type = \"l\",\n     bty = \"n\",\n     xlab = \"\",\n     ylab = \"\",\n     xaxt = \"n\",\n     yaxt = \"n\",\n     lwd = 2)\nlines(up ~ x)\nlines(low ~ x)\npolygon(c(x, rev(x)), c(up, rev(low)),\n        col = addTrans(\"grey30\",30), border = NA) #fills in the area between high and low confidence intervals\naxis(1, cex.axis = 0.7, at= c(0, 50, 100))\naxis(2, cex.axis = 0.7, at = c(0, 0.1, 0.2, .3))\nmtext(text = \"Percent dead canopy in 2005\", side = 1, cex = 0.8, line = 2.3)\nmtext(text = \"p(mortality), 2005-2015\", side = 2, cex = 0.8, line = 2.3)\n\n\ndev.off()\n\n\n#------------------------------------------------------------\n## Plots for bootstraps of variable values\n#-------------------------------------------------\n#Generate Figure 3\n\n#order for variables to be plotted\nvar_names <- character()\nvar_names[1] <- \"Intercept\"\nvar_names[2] <- \"Neigh. Rat. (log)\"\nvar_names[3] <- \"ENN Dist\"\nvar_names[4] <- \"4m BA (log)\"\nvar_names[5] <- \"Height\"\nvar_names[6] <- \"Diam (log)\"\nvar_names[7] <- \"4m BA : CWD\"\nvar_names[8] <- \"ENN Dist : Neigh. Rat.\"\n\n#manually select the order of variables to line up with the variable names\norder_p <- c(1, 9, 7, 5, 8, 6, 10)\norder_j <- c(1, 9, 7, 5, 8, 6, 10)\norder_pmort <- c(1, 2, 3, 6, 4, 5)\n\nopar <- par(no.readonly = TRUE)\n\npar(opar)\n\ntiff(filename=\"./plots/coefficient_density_plots.tif\", \n    type = \"cairo\",\n    antialias = \"gray\",\n    compression = \"lzw\",\n    units=\"in\", \n    width = 6, \n    height=4, \n    pointsize=15, \n    res=600)\n\npar(mar = c(1,1,1,0.6),\n    oma = c(1,5,0.2,0),\n    family = \"serif\")\n\nlayout(matrix(c(0,1,2,0,3,4,0,5,6,0,7,8,0,9,10,0,11,12,0,13,0,0,14,0,15,0,0), 9, 3, byrow = TRUE),\n       widths = rep(c(.3,2,1), times = 9),\n       heights = c(1.3,1,1,1,1,1,1,1))\n\n\n#loop over each variable\nfor (i in 1:length(var_names)){\n  \n  #pull out density plots for selected variables, controlled by the order_x lists defined above\n  if(i < 7){\n  d_p <- density(bootstrap_pimo_int$t[ , order_p[i]])\n  d_j <- density(bootstrap_juos$t[, order_j[i]])\n  d_pm <- density(bootstrap_pmort$t[, order_pmort[i]])}\n  \n  #changing assignment for the interaction terms\n  if(i > 6){\n    d_p <- density(bootstrap_pimo_int$t[ , order_p[7]])\n    d_j <- density(bootstrap_juos$t[, order_j[7]])\n  }\n\n  if(i == 1){ #different axes for intercept\n    \n    #plot pinyon and juniper dieback density plots\n    plot(NA,\n         xlim = c(min(c(min(d_p$x), min(d_j$x))), max(c(max(d_p$x), max(d_j$x)))),\n         ylim = c(0,max(c(max(d_p$y), max(d_j$y)))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_p, col = \"grey50\") #pinyon in darker grey\n    polygon(d_p, col = addTrans(\"grey50\", 90))\n    lines(d_j, col = \"grey90\", new = FALSE) #juniper in lighter grey\n    polygon(d_j, col = addTrans(\"grey90\", 60))\n    axis(1)\n\n    #label the row with the i'th value of the var_names vector\n    mtext(var_names[i],side=3,line=-1.8, \n          at=par(\"usr\")[1] - 3,\n          cex=.75,\n          adj = 1)\n    \n    mtext(\"Canopy dieback\", side = 3, cex = 0.9)\n    \n    \n    plot(NA,\n         xlim = c(min(d_pm$x), max(d_pm$x)),\n         ylim = c(min(d_pm$y), max(d_pm$y)),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_pm, col = \"blue\")\n    polygon(d_pm, col = addTrans(\"grey50\", 90))\n    axis(1)\n  #  axis(2)\n    \n    mtext(\"Pinyon mortality\", side = 3, cex = 0.9)\n    \n  } \n\n  \n  if(i > 1 & i <7){ #all other variables\n    \n    par(mar = c(0,0,1,0))\n    \n    plot(NA,\n         xlim = (c(-6,4)),\n         ylim = c(0,max(c(max(d_p$y), max(d_j$y)))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_p, col = \"black\")\n    polygon(d_p, col = addTrans(\"grey50\", 90))\n    lines(d_j, col = \"black\", new = FALSE)\n    polygon(d_j, col = addTrans(\"grey90\", 60))\n    axis(1, labels = FALSE)\n   # axis(2)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    mtext(var_names[i],side=3,line=-1.5, \n          at=par(\"usr\")[1] - .7,\n          cex=.75,\n          adj = 1)\n    \n    \n    \n    par(mar = c(0,0.6,1,0))\n    \n  plot(NA,\n         xlim = c(-1,2),\n         ylim = c(min(d_pm$y), max(d_pm$y)),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n       xlab = \"\",\n       ylab = \"\")\n    lines(d_pm, col = \"blue\")\n    polygon(d_pm, col = addTrans(\"grey50\", 90))\n    axis(1, at = c(-1, 0, 1, 2), labels = FALSE)\n   # axis(2)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    if (i == 6){axis(1, at = c(-1, 0, 1, 2))}\n  }\n\n  if(i == 7){ #interaction term for pinyon\n    par(mar = c(0,0,1,0))\n    \n    plot(NA,\n         xlim = (c(-6,4)),\n         ylim = c(0,(max(d_p$y))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_p, col = \"black\")\n    polygon(d_p, col = addTrans(\"grey50\", 90))\n    axis(1, labels = FALSE)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    mtext(var_names[7],side=3,line=-1.5, \n          at=par(\"usr\")[1] - .7,\n          cex=.75,\n          adj = 1)\n    \n  }\n  \n  if(i == 8){ #interaction term for juniper dieback\n    par(mar = c(0,0,1,0))\n    \n    plot(NA,\n         xlim = (c(-6,4)),\n         ylim = c(0,(max(d_j$y))),\n         xaxt = 'n', \n         yaxt = 'n',\n         bty = 'n',\n         xlab = \"\",\n         ylab = \"\")\n    lines(d_j, col = \"black\")\n    polygon(d_j, col = addTrans(\"grey90\", 60))\n    axis(1, labels = FALSE)\n    abline(v = 0, lwd = 2, lty = 2)\n    \n    mtext(\"ENN Dist :\\nNeigh. Rat.\",side=3,line=-2.5, \n          at=par(\"usr\")[1] - .7,\n          cex=.75,\n          adj = 1)\n    \n    axis(1)\n  }\n\n}\n\n\n\n\nmtext(text = \"Bootstrap coefficient estimates (scaled)\", side = 1,\n      line = 2.3, at = 0, cex = 0.9)\n\ndev.off()\n\n\n#####################################################################\n### Generate figure 4\n### multipanel figure\n#####################################################################\n## this is the ugliest, WETtest piece of code you've ever seen but it should work.\n## run this whole chunk until dev.off() way down there\n iff(filename=\"test_figure.tif\",\n     type=\"cairo\",\n     units=\"in\",\n     width = 6,\n     height = 6,\n     pointsize=15,\n     res=600,\n     compression = \"lzw\")\n\n\n\nlayout(matrix(c(1,2,3,4,5,6,7,8,9), nrow=3, ncol=3, byrow = TRUE))\npar(mar = c(3,.5,1.2,0), oma = c(2,4,1,1), family = \"serif\", bty = 'n', \n    cex = 0.7, cex.lab = 0.7, cex.axis = 0.7)\n\n\n# function to calculate standard errors for a given vcov matrix and row of x values, to get\n# point estimates of prediction error for a given prediction. See http://www.ats.ucla.edu/stat/r/faq/deltamethod.htm\n# This gets used for the confidence interval of the effects plot\n\ncalc.se <- function(x){\n  sqrt(as.matrix(x) %*% vcov(model) %*% t(x))\n} \n\n##############################################\n## Creating new predictions\n##############################################\n\n# Calculate residuals from predicted values and observed values\n# resid <- residuals(model)\n\n# for unscaling variables -- these things come from a full model in the model set, you'll have to change\n# the number or the path depending upon what kind of model object and the order of your models, etc.\n# You can also just get them from the raw data.\n\nalldata_scaled <- read.csv(\"pj_resample_plot_level_data_scaled.csv\")\n\nalldata_unscaled <- read.csv( \"pj_resample_plot_level_data_unscaled.csv\")\n\navg_BA_4m_mean <-  mean(alldata_unscaled$avg_BA_4m)\navg_BA_4m_sd <- sd(alldata_unscaled$avg_BA_4m)\n\nvpd_peak_anom_mean <- mean(alldata_unscaled$vpd_peak_anom)\nvpd_peak_anom_sd <- sd(alldata_unscaled$vpd_peak_anom)\n\nBA_4m_mean <- mean(log(all_tree_vars_orig[all_tree_vars_orig$Spp == \"PIMO\", \"BA_4m\"]+0.01))\nBA_4m_sd <- sd(log(all_tree_vars_orig[all_tree_vars_orig$Spp == \"PIMO\", \"BA_4m\"]+0.01))\n\nENN_dist_mean <- mean(log(all_tree_vars_orig[all_tree_vars_orig$Spp == \"JUOS\", \"ENN_dist\"]+0.01))\nENN_dist_sd <- sd(log(all_tree_vars_orig[all_tree_vars_orig$Spp == \"JUOS\", \"ENN_dist\"]+0.01))\n\n\n################################\n#generates figure 4a\n################################\npardefault <- par(no.readonly = T)\nsource('addTrans.R', echo=FALSE)\n\n# setwd(\"\")\n\n### set some parameters to be use throughout\nymax <- 50\nymin <- -500\n\n# model used for effects plot\nmodel <- lmer(Weighted_pdc ~ Avg_depth + avg_BA_4m + avg_summer_tmax + cwd_normal_cum + \n                vpd_peak_anom + avg_BA + avg_ENN + Pct_pimo + avg_BA_4m *vpd_peak_anom + (1|Cluster), data = alldata)\n\n\nranefs <- vector(mode = \"numeric\", length = 98) #initialize a vector for the ranefs\n\n#pull out the random intercept for each plot\nfor (i in (1:98)){\n  ranefs[i] <- ranef(model)$Cluster[rownames(ranef(model)$Cluster) == model@frame$Cluster[i], ]\n}\n\ncalculate_preds_avg_BA_4m <- function(quant){\n  C <- data.frame(\n    \"(Intercept)\" = 1,  \n    Avg_depth = 0,\n    avg_BA_4m = seq(min(alldata$avg_BA_4m), \n                    max(alldata$avg_BA_4m), \n                    length.out=nrow(alldata)),\n    avg_summer_tmax = 0,\n    cwd_normal_cum=0,\n    vpd_peak_anom = unname(quantile(alldata$vpd_peak_anom, quant)),\n    avg_BA = 0,\n    avg_ENN=0,\n    Pct_pimo = 0,\n    \"avg_BA_4m:vpd_peak_anom\" = seq(unname(quantile(alldata$vpd_peak_anom, quant))*min(alldata$avg_BA_4m), \n                                    unname(quantile(alldata$vpd_peak_anom, quant))*max(alldata$avg_BA_4m), \n                                    length.out=nrow(alldata))\n  )\n  \n  se <- vector(mode='numeric', length=nrow(C))\n  \n  for (i in 1:nrow(C)){\n    se[i] <- as.numeric(calc.se(C[i, ]))\n  }\n  \n  preds <- data.frame(\n    predictions = as.matrix(C) %*% as.matrix(fixef(model)),\n    lo = as.matrix(C) %*% as.matrix(fixef(model)) - 1.96*se,\n    hi = as.matrix(C) %*% as.matrix(fixef(model)) + 1.96*se,\n    avg_BA_4m_orig = model@frame$avg_BA_4m,\n    avg_BA_4m_sim = C$avg_BA_4m #,\n    # part_resids = part_resids\n  )\n  \n  return(preds)\n  \n}\n\n\nfor(i in 1:3){\n  values = c(0.1,0.5,0.9)\n  # Use the function to get all the stuff we need (predictions, partial residuals, and SEs)\n  pred <- calculate_preds_avg_BA_4m(values[i])\n  \n  #set up the empty plot window\n  plot(NA,\n       ylim = c(-400, 100),\n       xlim = c(0, max(I(((pred$avg_BA_4m_sim * avg_BA_4m_sd) + avg_BA_4m_mean)/10000))),\n       xlab = \"\",\n       ylab = \"\",\n       # log = \"x\",\n       cex.lab = 1.5,\n       xaxt = \"n\",\n       yaxt = \"n\"\n  )\n  \n  #draw prediction line and confidence envelope of predictions\n  lines(pred$predictions ~ I(((pred$avg_BA_4m_sim * avg_BA_4m_sd) + avg_BA_4m_mean)/10000), lwd = 2)\n  lines((pred$lo) ~ I(((pred$avg_BA_4m_sim * avg_BA_4m_sd) + avg_BA_4m_mean)/10000), lwd = 1.3) \n  lines((pred$hi) ~ I(((pred$avg_BA_4m_sim * avg_BA_4m_sd) + avg_BA_4m_mean)/10000), lwd = 1.3)\n  \n  #fill in the confidence envelope\n  polygon(c(I(((pred$avg_BA_4m_sim * avg_BA_4m_sd) + avg_BA_4m_mean)/10000), rev(I(((pred$avg_BA_4m_sim * avg_BA_4m_sd) + avg_BA_4m_mean)/10000))), c((pred$hi), rev((pred$lo))),\n          col = addTrans(\"grey\",30), border = NA)\n  \n  #label the levels of the interacting variable\n  text(x = 0.2, y = -0, labels = paste0(values[i]*100, \"% Peak VPD \\n Anomaly = \", \n                                        round(((unname(quantile(alldata$vpd_peak_anom, values[i])) * vpd_peak_anom_sd + vpd_peak_anom_mean)), 3)),\n       cex = 0.7)\n  \n  axis(1, at = c(0, .1, .2, .3)) #draw the x-axis\n  \n  #draw the y-axis just for the leftmost panel\n  \n  if(i == 1){\n    mtext(side = 3, at = 0, text= \"(a)\")\n    axis(2)\n    mtext(side = 2, text = \"Predicted Change in \\nPlot Weighted Canopy\", cex = 0.7, outer = FALSE, line = 1.7)}\n  \n  #label x axis\n  if(i == 2){mtext(side = 1, text = expression(paste(\"Avg 4m BA (\", m^2, \")\")), cex= 0.7, outer = FALSE, line = 2)}\n  \n}\n\n\n#label y axis\n\n\n\n\n\n#############################################################\n### Pimo part -- figure 4b\n#############################################################\n\nmodel <- pimo_int_ba\n\nymax <- 20\nymin <- -40\n\nnum_tree <- (nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]))\nranefs <- vector(mode = \"numeric\", length = num_tree) \n\n###BA_4meter\ncalculate_preds_BA_4m <- function(quant){\n  C <- data.frame(\n    '(Intercept)' = 1,\n    Neighbor_larger = 0,\n    ENN_dist = 0,\n    Height = 0,\n    Diam = 0,\n    BA_4m = seq(min(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]$BA_4m), \n                max(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]$BA_4m), \n                length.out=nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ])),\n    Avg_depth = 0,\n    cwd_normal_cum = unname(quantile(all_tree_vars$cwd_normal_cum, quant)),\n    vpd_normal_annual_max = 0,\n    vpd_peak_anom = 0,\n    'BA_4m:cwd_normal_cum' = seq(unname(quantile(all_tree_vars$cwd_normal_cum, quant))*\n                                   min(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]$BA_4m), \n                                 unname(quantile(all_tree_vars$cwd_normal_cum, quant))*\n                                   max(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]$BA_4m), \n                                 length.out=nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]))\n  )\n  \n  se <- vector(mode='numeric', length=nrow(C))\n  \n  #get prediction ses from above function\n  for (i in 1:nrow(C)){\n    se[i] <- as.numeric(calc.se(C[i, ]))\n  }\n  \n  preds <- data.frame(\n    predictions = as.matrix(C) %*% as.matrix(fixef(model)),\n    lo = as.matrix(C) %*% as.matrix(fixef(model)) - 1.96*se,\n    hi = as.matrix(C) %*% as.matrix(fixef(model)) + 1.96*se,\n    BA_4m = model@frame$`BA_4m`,\n    BA_4m_sim = C$BA_4m\n  )\n  \n  return(preds)\n  \n}\n\n# setwd(\"E:\\\\IALE analysis\\\\plots\") #where the plots go\n# \n\nfor(i in 1:3){\n  values = c(0.1,0.5,0.9)\n  # Use the function to get all the stuff we need (predictions, partial residuals, and SEs)\n  pred <- calculate_preds_BA_4m(values[i])\n  \n  \n  plot(NA,\n       ylim = c(-50, 0),\n       xlim = c(min(I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean))/10000), max(I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean))/10000)),\n       xlab = \"\",\n       ylab = \"\",\n       # log = \"x\",\n       cex.lab = 1.5,\n       xaxt = \"n\",\n       yaxt = \"n\"\n  )\n  \n  lines(pred$predictions ~ I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean)/10000), lwd = 2)\n  lines((pred$lo) ~ I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean)/10000), lwd = 1.3) \n  lines((pred$hi) ~ I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean)/10000), lwd = 1.3)\n  polygon(c(I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean)/10000), rev(I(exp((pred$BA_4m_sim * BA_4m_sd) + BA_4m_mean))/10000)), c((pred$hi), rev((pred$lo))),\n          col = addTrans(\"grey\",30), border = NA) #fills in the area between high and low confidence intervals\n  \n  \n  text(x = 0.7, y = -3, labels = paste0(values[i]*100, \"% CWD = \\n\", \n                                        round(((unname(quantile(all_tree_vars$cwd_normal_cum, values[i])) * cwd_normal_cum_sd + cwd_normal_cum_mean)), 0), \" mm\"),\n       cex = 0.7)\n  \n  axis(1)\n  \n  if(i == 1){\n    mtext(side = 3, at = 0, text= \"(b)\")\n    axis(2)\n    mtext(side = 2, text = \"Predicted Change in Crown\", cex = 0.7, outer = FALSE, line = 1.7)}\n  \n  #label x axis\n  if(i == 2){mtext(side = 1, text = expression(paste(\"BA, 4m buffer (\", m^2, \")\")), cex= 0.7, outer = FALSE, line = 2)}\n  \n}\n\n\n#######################################################\n### juos part -- figure 4c\n#######################################################\n\n\nmodel <- juos_int_enn\n\nnum_tree <- (nrow(all_tree_vars[all_tree_vars$Spp == \"PIMO\", ]))\nranefs <- vector(mode = \"numeric\", length = num_tree) \n\n###BA_4meter\ncalculate_preds_Neighbor_larger <- function(quant){\n  C <- data.frame(\n    '(Intercept)' = 1,\n    Neighbor_larger = seq(min(all_tree_vars[all_tree_vars$Spp == \"JUOS\", ]$Neighbor_larger), \n                          max(all_tree_vars[all_tree_vars$Spp == \"JUOS\", ]$Neighbor_larger), \n                          length.out=nrow(all_tree_vars[all_tree_vars$Spp == \"JUOS\", ])),\n    ENN_dist = unname(quantile(all_tree_vars$ENN_dist, quant)),\n    Height = 0,\n    Diam = 0,\n    BA_4m = 0,\n    fdsi_anom = 0,\n    avg_summer_tmax = 0,\n    Avg_depth = 0,\n    AWC = 0,\n    'Neighbor_larger:ENN_dist' = seq(unname(quantile(all_tree_vars$ENN_dist, quant))*\n                                       min(all_tree_vars[all_tree_vars$Spp == \"JUOS\", ]$Neighbor_larger), \n                                     unname(quantile(all_tree_vars$ENN_dist, quant))*\n                                       max(all_tree_vars[all_tree_vars$Spp == \"JUOS\", ]$Neighbor_larger), \n                                     length.out=nrow(all_tree_vars[all_tree_vars$Spp == \"JUOS\", ]))\n  )\n  \n  se <- vector(mode='numeric', length=nrow(C))\n  \n  #get prediction ses from above function\n  for (i in 1:nrow(C)){\n    se[i] <- as.numeric(calc.se(C[i, ]))\n  }\n  \n  preds <- data.frame(\n    predictions = as.matrix(C) %*% as.matrix(fixef(model)),\n    lo = as.matrix(C) %*% as.matrix(fixef(model)) - 1.96*se,\n    hi = as.matrix(C) %*% as.matrix(fixef(model)) + 1.96*se,\n    Neighbor_larger = model@frame$`Neighbor_larger`,\n    Neighbor_larger_sim = C$Neighbor_larger\n  )\n  \n  return(preds)\n  \n}\n\n\nfor(i in 1:3){\n  values = c(0.1,0.5,0.9)\n  # Use the function to get all the stuff we need (predictions, partial residuals, and SEs)\n  pred <- calculate_preds_Neighbor_larger(values[i])\n  \n  \n  plot(NA,\n       ylim = c(-25, 0),\n       xlim = c(min(I(exp((pred$Neighbor_larger * Neighbor_larger_sd) + Neighbor_larger_mean))), max(I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)))),\n       xlab = \"\",\n       ylab = \"\",\n       log = \"x\",\n       cex.lab = 1.5,\n       xaxt = \"n\",\n       yaxt = \"n\"\n  )\n  \n  lines(pred$predictions ~ I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), lwd = 2)\n  lines((pred$lo) ~ I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), lwd = 1.3) \n  lines((pred$hi) ~ I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), lwd = 1.3)\n  polygon(c(I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)), rev(I(exp((pred$Neighbor_larger_sim * Neighbor_larger_sd) + Neighbor_larger_mean)))), c((pred$hi), rev((pred$lo))),\n          col = addTrans(\"grey\",30), border = NA) #fills in the area between high and low confidence intervals\n  \n  ticks <- c(-2, 0, 2)\n  labels <- sapply(ticks, function(i) as.expression(bquote(10^ .(i))))\n  axis(1, at=c(0.01, 1, 100), labels=labels)\n  \n  text(x = 0.9, y = -3, labels = paste0(values[i]*100, \"% ENN Distance = \\n\", \n                                        round(exp((unname(quantile(all_tree_vars$ENN_dist, values[i])) * ENN_dist_sd + ENN_dist_mean)), 1), \" m\"),\n       cex = 0.7)\n  \n  \n  if(i == 1){\n    mtext(side = 3, at = 0.003, text= \"(c)\")\n    axis(2)\n    mtext(side = 2, text = \"Predicted Change in Crown\", cex = 0.7, outer = FALSE, line = 1.7)}\n  \n  #label x axis\n  if(i == 2){mtext(side = 1, text = \"Neighbor Size Ratio (log)\", cex= 0.7, outer = FALSE, line = 2)}\n  \n}\n\ndev.off()\n\n\n",
    "created" : 1506965893163.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3962186735",
    "id" : "E4798027",
    "lastKnownWriteTime" : 1506961208,
    "last_content_update" : 1506961208,
    "path" : "C:/Users/swflake/Google Drive/Projects/MS Thesis/Flake and Weisberg PJ mortality analysis/ind_tree_analysis_for_paper_100217.R",
    "project_path" : "ind_tree_analysis_for_paper_100217.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}